"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unraw";
exports.ids = ["vendor-chunks/unraw"];
exports.modules = {

/***/ "(ssr)/./node_modules/unraw/dist/errors.js":
/*!*******************************************!*\
  !*** ./node_modules/unraw/dist/errors.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// NOTE: don't construct errors here or they'll have the wrong stack trace.\n// NOTE: don't make custom error class; the JS engines use `SyntaxError`\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.errorMessages = exports.ErrorType = void 0;\n/**\n * Keys for possible error messages used by `unraw`.\n * Note: These do _not_ map to actual error object types. All errors thrown\n * are `SyntaxError`.\n */\n// Don't use const enum or JS users won't be able to access the enum values\nvar ErrorType;\n(function (ErrorType) {\n    /**\n     * Thrown when a badly formed Unicode escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\u25\"`) or having invalid\n     * characters (`\"\\u2$A5\"`).\n     */\n    ErrorType[\"MalformedUnicode\"] = \"MALFORMED_UNICODE\";\n    /**\n     * Thrown when a badly formed hexadecimal escape sequence is found. Possible\n     * reasons include the code being too short (`\"\\x2\"`) or having invalid\n     * characters (`\"\\x2$\"`).\n     */\n    ErrorType[\"MalformedHexadecimal\"] = \"MALFORMED_HEXADECIMAL\";\n    /**\n     * Thrown when a Unicode code point escape sequence has too high of a code\n     * point. The maximum code point allowed is `\\u{10FFFF}`, so `\\u{110000}` and\n     * higher will throw this error.\n     */\n    ErrorType[\"CodePointLimit\"] = \"CODE_POINT_LIMIT\";\n    /**\n     * Thrown when an octal escape sequences is encountered and `allowOctals` is\n     * `false`. For example, `unraw(\"\\234\", false)`.\n     */\n    ErrorType[\"OctalDeprecation\"] = \"OCTAL_DEPRECATION\";\n    /**\n     * Thrown only when a single backslash is found at the end of a string. For\n     * example, `\"\\\\\"` or `\"test\\\\x24\\\\\"`.\n     */\n    ErrorType[\"EndOfString\"] = \"END_OF_STRING\";\n})(ErrorType = exports.ErrorType || (exports.ErrorType = {}));\n/** Map of error message names to the full text of the message. */\nexports.errorMessages = new Map([\n    [ErrorType.MalformedUnicode, \"malformed Unicode character escape sequence\"],\n    [\n        ErrorType.MalformedHexadecimal,\n        \"malformed hexadecimal character escape sequence\"\n    ],\n    [\n        ErrorType.CodePointLimit,\n        \"Unicode codepoint must not be greater than 0x10FFFF in escape sequence\"\n    ],\n    [\n        ErrorType.OctalDeprecation,\n        '\"0\"-prefixed octal literals and octal escape sequences are deprecated; ' +\n            'for octal literals use the \"0o\" prefix instead'\n    ],\n    [ErrorType.EndOfString, \"malformed escape sequence at end of string\"]\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5yYXcvZGlzdC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4Qyw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU8sVUFBVSxPQUFPO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0MsaUJBQWlCLEtBQUs7QUFDM0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiUDpcXEdhbGVvbiBwcm9qZWN0c1xcZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXBcXG1haW5cXG5vZGVfbW9kdWxlc1xcdW5yYXdcXGRpc3RcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIE5PVEU6IGRvbid0IGNvbnN0cnVjdCBlcnJvcnMgaGVyZSBvciB0aGV5J2xsIGhhdmUgdGhlIHdyb25nIHN0YWNrIHRyYWNlLlxuLy8gTk9URTogZG9uJ3QgbWFrZSBjdXN0b20gZXJyb3IgY2xhc3M7IHRoZSBKUyBlbmdpbmVzIHVzZSBgU3ludGF4RXJyb3JgXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVycm9yTWVzc2FnZXMgPSBleHBvcnRzLkVycm9yVHlwZSA9IHZvaWQgMDtcbi8qKlxuICogS2V5cyBmb3IgcG9zc2libGUgZXJyb3IgbWVzc2FnZXMgdXNlZCBieSBgdW5yYXdgLlxuICogTm90ZTogVGhlc2UgZG8gX25vdF8gbWFwIHRvIGFjdHVhbCBlcnJvciBvYmplY3QgdHlwZXMuIEFsbCBlcnJvcnMgdGhyb3duXG4gKiBhcmUgYFN5bnRheEVycm9yYC5cbiAqL1xuLy8gRG9uJ3QgdXNlIGNvbnN0IGVudW0gb3IgSlMgdXNlcnMgd29uJ3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGVudW0gdmFsdWVzXG52YXIgRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChFcnJvclR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBUaHJvd24gd2hlbiBhIGJhZGx5IGZvcm1lZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBpcyBmb3VuZC4gUG9zc2libGVcbiAgICAgKiByZWFzb25zIGluY2x1ZGUgdGhlIGNvZGUgYmVpbmcgdG9vIHNob3J0IChgXCJcXHUyNVwiYCkgb3IgaGF2aW5nIGludmFsaWRcbiAgICAgKiBjaGFyYWN0ZXJzIChgXCJcXHUyJEE1XCJgKS5cbiAgICAgKi9cbiAgICBFcnJvclR5cGVbXCJNYWxmb3JtZWRVbmljb2RlXCJdID0gXCJNQUxGT1JNRURfVU5JQ09ERVwiO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGEgYmFkbHkgZm9ybWVkIGhleGFkZWNpbWFsIGVzY2FwZSBzZXF1ZW5jZSBpcyBmb3VuZC4gUG9zc2libGVcbiAgICAgKiByZWFzb25zIGluY2x1ZGUgdGhlIGNvZGUgYmVpbmcgdG9vIHNob3J0IChgXCJcXHgyXCJgKSBvciBoYXZpbmcgaW52YWxpZFxuICAgICAqIGNoYXJhY3RlcnMgKGBcIlxceDIkXCJgKS5cbiAgICAgKi9cbiAgICBFcnJvclR5cGVbXCJNYWxmb3JtZWRIZXhhZGVjaW1hbFwiXSA9IFwiTUFMRk9STUVEX0hFWEFERUNJTUFMXCI7XG4gICAgLyoqXG4gICAgICogVGhyb3duIHdoZW4gYSBVbmljb2RlIGNvZGUgcG9pbnQgZXNjYXBlIHNlcXVlbmNlIGhhcyB0b28gaGlnaCBvZiBhIGNvZGVcbiAgICAgKiBwb2ludC4gVGhlIG1heGltdW0gY29kZSBwb2ludCBhbGxvd2VkIGlzIGBcXHV7MTBGRkZGfWAsIHNvIGBcXHV7MTEwMDAwfWAgYW5kXG4gICAgICogaGlnaGVyIHdpbGwgdGhyb3cgdGhpcyBlcnJvci5cbiAgICAgKi9cbiAgICBFcnJvclR5cGVbXCJDb2RlUG9pbnRMaW1pdFwiXSA9IFwiQ09ERV9QT0lOVF9MSU1JVFwiO1xuICAgIC8qKlxuICAgICAqIFRocm93biB3aGVuIGFuIG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgaXMgZW5jb3VudGVyZWQgYW5kIGBhbGxvd09jdGFsc2AgaXNcbiAgICAgKiBgZmFsc2VgLiBGb3IgZXhhbXBsZSwgYHVucmF3KFwiXFwyMzRcIiwgZmFsc2UpYC5cbiAgICAgKi9cbiAgICBFcnJvclR5cGVbXCJPY3RhbERlcHJlY2F0aW9uXCJdID0gXCJPQ1RBTF9ERVBSRUNBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRocm93biBvbmx5IHdoZW4gYSBzaW5nbGUgYmFja3NsYXNoIGlzIGZvdW5kIGF0IHRoZSBlbmQgb2YgYSBzdHJpbmcuIEZvclxuICAgICAqIGV4YW1wbGUsIGBcIlxcXFxcImAgb3IgYFwidGVzdFxcXFx4MjRcXFxcXCJgLlxuICAgICAqL1xuICAgIEVycm9yVHlwZVtcIkVuZE9mU3RyaW5nXCJdID0gXCJFTkRfT0ZfU1RSSU5HXCI7XG59KShFcnJvclR5cGUgPSBleHBvcnRzLkVycm9yVHlwZSB8fCAoZXhwb3J0cy5FcnJvclR5cGUgPSB7fSkpO1xuLyoqIE1hcCBvZiBlcnJvciBtZXNzYWdlIG5hbWVzIHRvIHRoZSBmdWxsIHRleHQgb2YgdGhlIG1lc3NhZ2UuICovXG5leHBvcnRzLmVycm9yTWVzc2FnZXMgPSBuZXcgTWFwKFtcbiAgICBbRXJyb3JUeXBlLk1hbGZvcm1lZFVuaWNvZGUsIFwibWFsZm9ybWVkIFVuaWNvZGUgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiXSxcbiAgICBbXG4gICAgICAgIEVycm9yVHlwZS5NYWxmb3JtZWRIZXhhZGVjaW1hbCxcbiAgICAgICAgXCJtYWxmb3JtZWQgaGV4YWRlY2ltYWwgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiXG4gICAgXSxcbiAgICBbXG4gICAgICAgIEVycm9yVHlwZS5Db2RlUG9pbnRMaW1pdCxcbiAgICAgICAgXCJVbmljb2RlIGNvZGVwb2ludCBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gMHgxMEZGRkYgaW4gZXNjYXBlIHNlcXVlbmNlXCJcbiAgICBdLFxuICAgIFtcbiAgICAgICAgRXJyb3JUeXBlLk9jdGFsRGVwcmVjYXRpb24sXG4gICAgICAgICdcIjBcIi1wcmVmaXhlZCBvY3RhbCBsaXRlcmFscyBhbmQgb2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgZGVwcmVjYXRlZDsgJyArXG4gICAgICAgICAgICAnZm9yIG9jdGFsIGxpdGVyYWxzIHVzZSB0aGUgXCIwb1wiIHByZWZpeCBpbnN0ZWFkJ1xuICAgIF0sXG4gICAgW0Vycm9yVHlwZS5FbmRPZlN0cmluZywgXCJtYWxmb3JtZWQgZXNjYXBlIHNlcXVlbmNlIGF0IGVuZCBvZiBzdHJpbmdcIl1cbl0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unraw/dist/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/unraw/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/unraw/dist/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unraw = exports.errorMessages = exports.ErrorType = void 0;\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/unraw/dist/errors.js\");\nObject.defineProperty(exports, \"ErrorType\", ({ enumerable: true, get: function () { return errors_1.ErrorType; } }));\nObject.defineProperty(exports, \"errorMessages\", ({ enumerable: true, get: function () { return errors_1.errorMessages; } }));\n/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex) {\n    const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n    return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex, errorName, enforcedLength) {\n    const parsedHex = parseHexToInt(hex);\n    if (Number.isNaN(parsedHex) ||\n        (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errorName));\n    }\n    return parsedHex;\n}\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedHexadecimal, 2);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code, surrogateCode) {\n    const parsedCode = validateAndParseHex(code, errors_1.ErrorType.MalformedUnicode, 4);\n    if (surrogateCode !== undefined) {\n        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);\n        return String.fromCharCode(parsedCode, parsedSurrogateCode);\n    }\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text) {\n    return text.charAt(0) === \"{\" && text.charAt(text.length - 1) === \"}\";\n}\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint) {\n    if (!isCurlyBraced(codePoint)) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));\n    }\n    const withoutBraces = codePoint.slice(1, -1);\n    const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);\n    try {\n        return String.fromCodePoint(parsedCode);\n    }\n    catch (err) {\n        throw err instanceof RangeError\n            ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit))\n            : err;\n    }\n}\n// Have to give overload that takes boolean for when compiler doesn't know if\n// true or false\nfunction parseOctalCode(code, error = false) {\n    if (error) {\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));\n    }\n    // The original regex only allows digits so we don't need to have a strict\n    // octal parser like hexToInt. Length is not enforced for octals.\n    const parsedCode = parseInt(code, 8);\n    return String.fromCharCode(parsedCode);\n}\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map([\n    [\"b\", \"\\b\"],\n    [\"f\", \"\\f\"],\n    [\"n\", \"\\n\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"],\n    [\"v\", \"\\v\"],\n    [\"0\", \"\\0\"]\n]);\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code) {\n    return singleCharacterEscapes.get(code) || code;\n}\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch = /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nfunction unraw(raw, allowOctals = false) {\n    return raw.replace(escapeMatch, function (_, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {\n        // Compare groups to undefined because empty strings mean different errors\n        // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n        if (backslash !== undefined) {\n            return \"\\\\\";\n        }\n        if (hex !== undefined) {\n            return parseHexadecimalCode(hex);\n        }\n        if (codePoint !== undefined) {\n            return parseUnicodeCodePointCode(codePoint);\n        }\n        if (unicodeWithSurrogate !== undefined) {\n            return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n        }\n        if (unicode !== undefined) {\n            return parseUnicodeCode(unicode);\n        }\n        if (octal === \"0\") {\n            return \"\\0\";\n        }\n        if (octal !== undefined) {\n            return parseOctalCode(octal, !allowOctals);\n        }\n        if (singleCharacter !== undefined) {\n            return parseSingleCharacterCode(singleCharacter);\n        }\n        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));\n    });\n}\nexports.unraw = unraw;\nexports[\"default\"] = unraw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5yYXcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCO0FBQ3pELGlCQUFpQixtQkFBTyxDQUFDLDJEQUFVO0FBQ25DLDZDQUE0QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUNsSCxpREFBZ0QsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUksTUFBTSxHQUFHLElBQUksWUFBWSxFQUFFLFFBQVEsUUFBUSxJQUFJLFdBQVcsSUFBSSxlQUFlLElBQUk7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYixrQkFBZSIsInNvdXJjZXMiOlsiUDpcXEdhbGVvbiBwcm9qZWN0c1xcZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXBcXG1haW5cXG5vZGVfbW9kdWxlc1xcdW5yYXdcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51bnJhdyA9IGV4cG9ydHMuZXJyb3JNZXNzYWdlcyA9IGV4cG9ydHMuRXJyb3JUeXBlID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvclR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkVycm9yVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVycm9yTWVzc2FnZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLmVycm9yTWVzc2FnZXM7IH0gfSk7XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGFzIGEgYmFzZS0xNiBudW1iZXIuIFRoaXMgaXMgbW9yZSBzdHJpY3QgdGhhbiBgcGFyc2VJbnRgIGFzIGl0XG4gKiB3aWxsIG5vdCBhbGxvdyBhbnkgb3RoZXIgY2hhcmFjdGVycywgaW5jbHVkaW5nIChmb3IgZXhhbXBsZSkgXCIrXCIsIFwiLVwiLCBhbmRcbiAqIFwiLlwiLlxuICogQHBhcmFtIGhleCBBIHN0cmluZyBjb250YWluaW5nIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBpbnRlZ2VyLCBvciBgTmFOYCBpZiB0aGUgc3RyaW5nIGlzIG5vdCBhIHZhbGlkIGhleFxuICogbnVtYmVyLlxuICovXG5mdW5jdGlvbiBwYXJzZUhleFRvSW50KGhleCkge1xuICAgIGNvbnN0IGlzT25seUhleENoYXJzID0gIWhleC5tYXRjaCgvW15hLWYwLTldL2kpO1xuICAgIHJldHVybiBpc09ubHlIZXhDaGFycyA/IHBhcnNlSW50KGhleCwgMTYpIDogTmFOO1xufVxuLyoqXG4gKiBDaGVjayB0aGUgdmFsaWRpdHkgYW5kIGxlbmd0aCBvZiBhIGhleGFkZWNpbWFsIGNvZGUgYW5kIG9wdGlvbmFsbHkgZW5mb3JjZXNcbiAqIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGhleCBkaWdpdHMuXG4gKiBAcGFyYW0gaGV4IFRoZSBzdHJpbmcgdG8gdmFsaWRhdGUgYW5kIHBhcnNlLlxuICogQHBhcmFtIGVycm9yTmFtZSBUaGUgbmFtZSBvZiB0aGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdyBhIGBTeW50YXhFcnJvcmAgd2l0aFxuICogaWYgYGhleGAgaXMgaW52YWxpZC4gVGhpcyBpcyB1c2VkIHRvIGluZGV4IGBlcnJvck1lc3NhZ2VzYC5cbiAqIEBwYXJhbSBlbmZvcmNlZExlbmd0aCBJZiBwcm92aWRlZCwgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBgaGV4YCBpcyBub3RcbiAqIGV4YWN0bHkgdGhpcyBtYW55IGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIGhleCBudW1iZXIgYXMgYSBub3JtYWwgbnVtYmVyLlxuICogQHRocm93cyB7U3ludGF4RXJyb3J9IElmIHRoZSBjb2RlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBbmRQYXJzZUhleChoZXgsIGVycm9yTmFtZSwgZW5mb3JjZWRMZW5ndGgpIHtcbiAgICBjb25zdCBwYXJzZWRIZXggPSBwYXJzZUhleFRvSW50KGhleCk7XG4gICAgaWYgKE51bWJlci5pc05hTihwYXJzZWRIZXgpIHx8XG4gICAgICAgIChlbmZvcmNlZExlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGVuZm9yY2VkTGVuZ3RoICE9PSBoZXgubGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3JzXzEuZXJyb3JNZXNzYWdlcy5nZXQoZXJyb3JOYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRIZXg7XG59XG4vKipcbiAqIFBhcnNlIGEgdHdvLWRpZ2l0IGhleGFkZWNpbWFsIGNoYXJhY3RlciBlc2NhcGUgY29kZS5cbiAqIEBwYXJhbSBjb2RlIFRoZSB0d28tZGlnaXQgaGV4YWRlY2ltYWwgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhcmFjdGVyIHRvXG4gKiBvdXRwdXQuXG4gKiBAcmV0dXJucyBUaGUgc2luZ2xlIGNoYXJhY3RlciByZXByZXNlbnRlZCBieSB0aGUgY29kZS5cbiAqIEB0aHJvd3Mge1N5bnRheEVycm9yfSBJZiB0aGUgY29kZSBpcyBub3QgdmFsaWQgaGV4IG9yIGlzIG5vdCB0aGUgcmlnaHRcbiAqIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VIZXhhZGVjaW1hbENvZGUoY29kZSkge1xuICAgIGNvbnN0IHBhcnNlZENvZGUgPSB2YWxpZGF0ZUFuZFBhcnNlSGV4KGNvZGUsIGVycm9yc18xLkVycm9yVHlwZS5NYWxmb3JtZWRIZXhhZGVjaW1hbCwgMik7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VkQ29kZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgZm91ci1kaWdpdCBVbmljb2RlIGNoYXJhY3RlciBlc2NhcGUgY29kZS5cbiAqIEBwYXJhbSBjb2RlIFRoZSBmb3VyLWRpZ2l0IHVuaWNvZGUgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhcmFjdGVyIHRvXG4gKiBvdXRwdXQuXG4gKiBAcGFyYW0gc3Vycm9nYXRlQ29kZSBPcHRpb25hbCBmb3VyLWRpZ2l0IHVuaWNvZGUgc3Vycm9nYXRlIHRoYXQgcmVwcmVzZW50c1xuICogdGhlIG90aGVyIGhhbGYgb2YgdGhlIGNoYXJhY3RlciB0byBvdXRwdXQuXG4gKiBAcmV0dXJucyBUaGUgc2luZ2xlIGNoYXJhY3RlciByZXByZXNlbnRlZCBieSB0aGUgY29kZS5cbiAqIEB0aHJvd3Mge1N5bnRheEVycm9yfSBJZiB0aGUgY29kZXMgYXJlIG5vdCB2YWxpZCBoZXggb3IgYXJlIG5vdCB0aGUgcmlnaHRcbiAqIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbmljb2RlQ29kZShjb2RlLCBzdXJyb2dhdGVDb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkQ29kZSA9IHZhbGlkYXRlQW5kUGFyc2VIZXgoY29kZSwgZXJyb3JzXzEuRXJyb3JUeXBlLk1hbGZvcm1lZFVuaWNvZGUsIDQpO1xuICAgIGlmIChzdXJyb2dhdGVDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkU3Vycm9nYXRlQ29kZSA9IHZhbGlkYXRlQW5kUGFyc2VIZXgoc3Vycm9nYXRlQ29kZSwgZXJyb3JzXzEuRXJyb3JUeXBlLk1hbGZvcm1lZFVuaWNvZGUsIDQpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZWRDb2RlLCBwYXJzZWRTdXJyb2dhdGVDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VkQ29kZSk7XG59XG4vKipcbiAqIFRlc3QgaWYgdGhlIHRleHQgaXMgc3Vycm91bmRlZCBieSBjdXJseSBicmFjZXMgKGB7fWApLlxuICogQHBhcmFtIHRleHQgVGV4dCB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGV4dCBpcyBpbiB0aGUgZm9ybSBgeyp9YC5cbiAqL1xuZnVuY3Rpb24gaXNDdXJseUJyYWNlZCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQuY2hhckF0KDApID09PSBcIntcIiAmJiB0ZXh0LmNoYXJBdCh0ZXh0Lmxlbmd0aCAtIDEpID09PSBcIn1cIjtcbn1cbi8qKlxuICogUGFyc2UgYSBVbmljb2RlIGNvZGUgcG9pbnQgY2hhcmFjdGVyIGVzY2FwZSBjb2RlLlxuICogQHBhcmFtIGNvZGVQb2ludCBBIHVuaWNvZGUgZXNjYXBlIGNvZGUgcG9pbnQsIGluY2x1ZGluZyB0aGUgc3Vycm91bmRpbmcgY3VybHlcbiAqIGJyYWNlcy5cbiAqIEByZXR1cm5zIFRoZSBzaW5nbGUgY2hhcmFjdGVyIHJlcHJlc2VudGVkIGJ5IHRoZSBjb2RlLlxuICogQHRocm93cyB7U3ludGF4RXJyb3J9IElmIHRoZSBjb2RlIGlzIG5vdCB2YWxpZCBoZXggb3IgZG9lcyBub3QgaGF2ZSB0aGVcbiAqIHN1cnJvdW5kaW5nIGN1cmx5IGJyYWNlcy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbmljb2RlQ29kZVBvaW50Q29kZShjb2RlUG9pbnQpIHtcbiAgICBpZiAoIWlzQ3VybHlCcmFjZWQoY29kZVBvaW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3JzXzEuZXJyb3JNZXNzYWdlcy5nZXQoZXJyb3JzXzEuRXJyb3JUeXBlLk1hbGZvcm1lZFVuaWNvZGUpKTtcbiAgICB9XG4gICAgY29uc3Qgd2l0aG91dEJyYWNlcyA9IGNvZGVQb2ludC5zbGljZSgxLCAtMSk7XG4gICAgY29uc3QgcGFyc2VkQ29kZSA9IHZhbGlkYXRlQW5kUGFyc2VIZXgod2l0aG91dEJyYWNlcywgZXJyb3JzXzEuRXJyb3JUeXBlLk1hbGZvcm1lZFVuaWNvZGUpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZWRDb2RlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBlcnIgaW5zdGFuY2VvZiBSYW5nZUVycm9yXG4gICAgICAgICAgICA/IG5ldyBTeW50YXhFcnJvcihlcnJvcnNfMS5lcnJvck1lc3NhZ2VzLmdldChlcnJvcnNfMS5FcnJvclR5cGUuQ29kZVBvaW50TGltaXQpKVxuICAgICAgICAgICAgOiBlcnI7XG4gICAgfVxufVxuLy8gSGF2ZSB0byBnaXZlIG92ZXJsb2FkIHRoYXQgdGFrZXMgYm9vbGVhbiBmb3Igd2hlbiBjb21waWxlciBkb2Vzbid0IGtub3cgaWZcbi8vIHRydWUgb3IgZmFsc2VcbmZ1bmN0aW9uIHBhcnNlT2N0YWxDb2RlKGNvZGUsIGVycm9yID0gZmFsc2UpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGVycm9yc18xLmVycm9yTWVzc2FnZXMuZ2V0KGVycm9yc18xLkVycm9yVHlwZS5PY3RhbERlcHJlY2F0aW9uKSk7XG4gICAgfVxuICAgIC8vIFRoZSBvcmlnaW5hbCByZWdleCBvbmx5IGFsbG93cyBkaWdpdHMgc28gd2UgZG9uJ3QgbmVlZCB0byBoYXZlIGEgc3RyaWN0XG4gICAgLy8gb2N0YWwgcGFyc2VyIGxpa2UgaGV4VG9JbnQuIExlbmd0aCBpcyBub3QgZW5mb3JjZWQgZm9yIG9jdGFscy5cbiAgICBjb25zdCBwYXJzZWRDb2RlID0gcGFyc2VJbnQoY29kZSwgOCk7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VkQ29kZSk7XG59XG4vKipcbiAqIE1hcCBvZiB1bmVzY2FwZWQgbGV0dGVycyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHNwZWNpYWwgSlMgZXNjYXBlIGNoYXJhY3RlcnMuXG4gKiBJbnRlbnRpb25hbGx5IGRvZXMgbm90IGluY2x1ZGUgY2hhcmFjdGVycyB0aGF0IG1hcCB0byB0aGVtc2VsdmVzIGxpa2UgXCJcXCdcIi5cbiAqL1xuY29uc3Qgc2luZ2xlQ2hhcmFjdGVyRXNjYXBlcyA9IG5ldyBNYXAoW1xuICAgIFtcImJcIiwgXCJcXGJcIl0sXG4gICAgW1wiZlwiLCBcIlxcZlwiXSxcbiAgICBbXCJuXCIsIFwiXFxuXCJdLFxuICAgIFtcInJcIiwgXCJcXHJcIl0sXG4gICAgW1widFwiLCBcIlxcdFwiXSxcbiAgICBbXCJ2XCIsIFwiXFx2XCJdLFxuICAgIFtcIjBcIiwgXCJcXDBcIl1cbl0pO1xuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlIGFuZCByZXR1cm4gdGhlIG1hdGNoaW5nIGNoYXJhY3Rlci5cbiAqIElmIG5vbmUgaXMgbWF0Y2hlZCwgZGVmYXVsdHMgdG8gYGNvZGVgLlxuICogQHBhcmFtIGNvZGUgQSBzaW5nbGUgY2hhcmFjdGVyIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlQ2hhcmFjdGVyQ29kZShjb2RlKSB7XG4gICAgcmV0dXJuIHNpbmdsZUNoYXJhY3RlckVzY2FwZXMuZ2V0KGNvZGUpIHx8IGNvZGU7XG59XG4vKipcbiAqIE1hdGNoZXMgZXZlcnkgZXNjYXBlIHNlcXVlbmNlIHBvc3NpYmxlLCBpbmNsdWRpbmcgaW52YWxpZCBvbmVzLlxuICpcbiAqIEFsbCBjYXB0dXJlIGdyb3VwcyAoZGVzY3JpYmVkIGJlbG93KSBhcmUgdW5pcXVlIChvbmx5IG9uZSB3aWxsIG1hdGNoKSwgZXhjZXB0XG4gKiBmb3IgNCwgd2hpY2ggY2FuIG9ubHkgcG90ZW50aWFsbHkgbWF0Y2ggaWYgMyBkb2VzLlxuICpcbiAqICoqQ2FwdHVyZSBHcm91cHM6KipcbiAqIDAuIEEgc2luZ2xlIGJhY2tzbGFzaFxuICogMS4gSGV4YWRlY2ltYWwgY29kZVxuICogMi4gVW5pY29kZSBjb2RlIHBvaW50IGNvZGUgd2l0aCBzdXJyb3VuZGluZyBjdXJseSBicmFjZXNcbiAqIDMuIFVuaWNvZGUgZXNjYXBlIGNvZGUgd2l0aCBzdXJyb2dhdGVcbiAqIDQuIFN1cnJvZ2F0ZSBjb2RlXG4gKiA1LiBVbmljb2RlIGVzY2FwZSBjb2RlIHdpdGhvdXQgc3Vycm9nYXRlXG4gKiA2LiBPY3RhbCBjb2RlIF9OT1RFOiBpbmNsdWRlcyBcIjBcIi5fXG4gKiA3LiBBIHNpbmdsZSBjaGFyYWN0ZXIgKHdpbGwgbmV2ZXIgYmUgXFwsIHgsIHUsIG9yIDAtMylcbiAqL1xuY29uc3QgZXNjYXBlTWF0Y2ggPSAvXFxcXCg/OihcXFxcKXx4KFtcXHNcXFNdezAsMn0pfHUoXFx7W159XSpcXH0/KXx1KFtcXHNcXFNdezR9KVxcXFx1KFtee11bXFxzXFxTXXswLDN9KXx1KFtcXHNcXFNdezAsNH0pfChbMC0zXT9bMC03XXsxLDJ9KXwoW1xcc1xcU10pfCQpL2c7XG4vKipcbiAqIFJlcGxhY2UgcmF3IGVzY2FwZSBjaGFyYWN0ZXIgc3RyaW5ncyB3aXRoIHRoZWlyIGVzY2FwZSBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHJhdyBBIHN0cmluZyB3aGVyZSBlc2NhcGUgY2hhcmFjdGVycyBhcmUgcmVwcmVzZW50ZWQgYXMgcmF3IHN0cmluZ1xuICogdmFsdWVzIGxpa2UgYFxcJ2AgcmF0aGVyIHRoYW4gYCdgLlxuICogQHBhcmFtIGFsbG93T2N0YWxzIElmIGB0cnVlYCwgd2lsbCBwcm9jZXNzIHRoZSBub3ctZGVwcmVjYXRlZCBvY3RhbCBlc2NhcGVcbiAqIHNlcXVlbmNlcyAoaWUsIGBcXDExMWApLlxuICogQHJldHVybnMgVGhlIHByb2Nlc3NlZCBzdHJpbmcsIHdpdGggZXNjYXBlIGNoYXJhY3RlcnMgcmVwbGFjZWQgYnkgdGhlaXJcbiAqIHJlc3BlY3RpdmUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24gdW5yYXcocmF3LCBhbGxvd09jdGFscyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHJhdy5yZXBsYWNlKGVzY2FwZU1hdGNoLCBmdW5jdGlvbiAoXywgYmFja3NsYXNoLCBoZXgsIGNvZGVQb2ludCwgdW5pY29kZVdpdGhTdXJyb2dhdGUsIHN1cnJvZ2F0ZSwgdW5pY29kZSwgb2N0YWwsIHNpbmdsZUNoYXJhY3Rlcikge1xuICAgICAgICAvLyBDb21wYXJlIGdyb3VwcyB0byB1bmRlZmluZWQgYmVjYXVzZSBlbXB0eSBzdHJpbmdzIG1lYW4gZGlmZmVyZW50IGVycm9yc1xuICAgICAgICAvLyBPdGhlcndpc2UsIGBcXHVgIHdvdWxkIGZhaWwgdGhlIHNhbWUgYXMgYFxcYCB3aGljaCBpcyB3cm9uZy5cbiAgICAgICAgaWYgKGJhY2tzbGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VIZXhhZGVjaW1hbENvZGUoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVuaWNvZGVDb2RlUG9pbnRDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaWNvZGVXaXRoU3Vycm9nYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVuaWNvZGVDb2RlKHVuaWNvZGVXaXRoU3Vycm9nYXRlLCBzdXJyb2dhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmljb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVVuaWNvZGVDb2RlKHVuaWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvY3RhbCA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlxcMFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvY3RhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VPY3RhbENvZGUob2N0YWwsICFhbGxvd09jdGFscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmdsZUNoYXJhY3RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VTaW5nbGVDaGFyYWN0ZXJDb2RlKHNpbmdsZUNoYXJhY3Rlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGVycm9yc18xLmVycm9yTWVzc2FnZXMuZ2V0KGVycm9yc18xLkVycm9yVHlwZS5FbmRPZlN0cmluZykpO1xuICAgIH0pO1xufVxuZXhwb3J0cy51bnJhdyA9IHVucmF3O1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5yYXc7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unraw/dist/index.js\n");

/***/ })

};
;