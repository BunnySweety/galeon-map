"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lingui";
exports.ids = ["vendor-chunks/@lingui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lingui/core/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@lingui/core/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18n: () => (/* binding */ I18n),\n/* harmony export */   formats: () => (/* binding */ formats),\n/* harmony export */   i18n: () => (/* binding */ i18n),\n/* harmony export */   setupI18n: () => (/* binding */ setupI18n)\n/* harmony export */ });\n/* harmony import */ var _lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lingui/message-utils/compileMessage */ \"(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs\");\n\n\nconst isString = (s) => typeof s === \"string\";\nconst isFunction = (f) => typeof f === \"function\";\n\nconst cache = /* @__PURE__ */ new Map();\nconst defaultLocale = \"en\";\nfunction normalizeLocales(locales) {\n  const out = Array.isArray(locales) ? locales : [locales];\n  return [...out, defaultLocale];\n}\nfunction date(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  if (!format) {\n    format = \"default\";\n  }\n  let o;\n  if (typeof format === \"string\") {\n    o = {\n      day: \"numeric\",\n      month: \"short\",\n      year: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n        o.weekday = \"long\";\n      case \"long\":\n        o.month = \"long\";\n        break;\n      case \"short\":\n        o.month = \"numeric\";\n        break;\n    }\n  } else {\n    o = format;\n  }\n  const formatter = getMemoized(\n    () => cacheKey(\"date\", _locales, format),\n    () => new Intl.DateTimeFormat(_locales, o)\n  );\n  return formatter.format(isString(value) ? new Date(value) : value);\n}\nfunction time(locales, value, format) {\n  let o;\n  if (!format) {\n    format = \"default\";\n  }\n  if (typeof format === \"string\") {\n    o = {\n      second: \"numeric\",\n      minute: \"numeric\",\n      hour: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n      case \"long\":\n        o.timeZoneName = \"short\";\n        break;\n      case \"short\":\n        delete o.second;\n    }\n  } else {\n    o = format;\n  }\n  return date(locales, value, o);\n}\nfunction number(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"number\", _locales, format),\n    () => new Intl.NumberFormat(_locales, format)\n  );\n  return formatter.format(value);\n}\nfunction plural(locales, ordinal, value, { offset = 0, ...rules }) {\n  const _locales = normalizeLocales(locales);\n  const plurals = ordinal ? getMemoized(\n    () => cacheKey(\"plural-ordinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"ordinal\" })\n  ) : getMemoized(\n    () => cacheKey(\"plural-cardinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"cardinal\" })\n  );\n  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;\n}\nfunction getMemoized(getKey, construct) {\n  const key = getKey();\n  let formatter = cache.get(key);\n  if (!formatter) {\n    formatter = construct();\n    cache.set(key, formatter);\n  }\n  return formatter;\n}\nfunction cacheKey(type, locales, options) {\n  const localeKey = locales.join(\"-\");\n  return `${type}-${localeKey}-${JSON.stringify(options)}`;\n}\n\nconst formats = {\n  __proto__: null,\n  date: date,\n  defaultLocale: defaultLocale,\n  number: number,\n  plural: plural,\n  time: time\n};\n\nconst ESCAPE_SEQUENCE_REGEX = /\\\\u[a-fA-F0-9]{4}|\\\\x[a-fA-F0-9]{2}/;\nconst decodeEscapeSequences = (str) => {\n  return str.replace(\n    // Same pattern but with capturing groups for extracting values during replacement\n    /\\\\u([a-fA-F0-9]{4})|\\\\x([a-fA-F0-9]{2})/g,\n    (_, unicode, hex) => {\n      if (unicode) {\n        const codePoint = parseInt(unicode, 16);\n        return String.fromCharCode(codePoint);\n      } else {\n        const codePoint = parseInt(hex, 16);\n        return String.fromCharCode(codePoint);\n      }\n    }\n  );\n};\n\nconst OCTOTHORPE_PH = \"%__lingui_octothorpe__%\";\nconst getDefaultFormats = (locale, passedLocales, formats = {}) => {\n  const locales = passedLocales || locale;\n  const style = (format) => {\n    if (typeof format === \"object\")\n      return format;\n    return formats[format];\n  };\n  const replaceOctothorpe = (value, message) => {\n    const numberFormat = Object.keys(formats).length ? style(\"number\") : void 0;\n    const valueStr = number(locales, value, numberFormat);\n    return message.replace(new RegExp(OCTOTHORPE_PH, \"g\"), valueStr);\n  };\n  return {\n    plural: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, false, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, true, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: selectFormatter,\n    number: (value, format) => number(\n      locales,\n      value,\n      style(format) || { style: format }\n    ),\n    date: (value, format) => date(locales, value, style(format) || format),\n    time: (value, format) => time(locales, value, style(format) || format)\n  };\n};\nconst selectFormatter = (value, rules) => rules[value] ?? rules.other;\nfunction interpolate(translation, locale, locales) {\n  return (values = {}, formats) => {\n    const formatters = getDefaultFormats(locale, locales, formats);\n    const formatMessage = (tokens, replaceOctothorpe = false) => {\n      if (!Array.isArray(tokens))\n        return tokens;\n      return tokens.reduce((message, token) => {\n        if (token === \"#\" && replaceOctothorpe) {\n          return message + OCTOTHORPE_PH;\n        }\n        if (isString(token)) {\n          return message + token;\n        }\n        const [name, type, format] = token;\n        let interpolatedFormat = {};\n        if (type === \"plural\" || type === \"selectordinal\" || type === \"select\") {\n          Object.entries(format).forEach(\n            ([key, value2]) => {\n              interpolatedFormat[key] = formatMessage(\n                value2,\n                type === \"plural\" || type === \"selectordinal\"\n              );\n            }\n          );\n        } else {\n          interpolatedFormat = format;\n        }\n        let value;\n        if (type) {\n          const formatter = formatters[type];\n          value = formatter(values[name], interpolatedFormat);\n        } else {\n          value = values[name];\n        }\n        if (value == null) {\n          return message;\n        }\n        return message + value;\n      }, \"\");\n    };\n    const result = formatMessage(translation);\n    if (isString(result) && ESCAPE_SEQUENCE_REGEX.test(result)) {\n      return decodeEscapeSequences(result);\n    }\n    if (isString(result))\n      return result;\n    return result ? String(result) : \"\";\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventEmitter {\n  constructor() {\n    __publicField$1(this, \"_events\", {});\n  }\n  on(event, listener) {\n    var _a;\n    (_a = this._events)[event] ?? (_a[event] = []);\n    this._events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n  removeListener(event, listener) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    const index = maybeListeners.indexOf(listener);\n    if (~index)\n      maybeListeners.splice(index, 1);\n  }\n  emit(event, ...args) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    maybeListeners.map((listener) => listener.apply(this, args));\n  }\n  _getListeners(event) {\n    const maybeListeners = this._events[event];\n    return Array.isArray(maybeListeners) ? maybeListeners : false;\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass I18n extends EventEmitter {\n  constructor(params) {\n    super();\n    __publicField(this, \"_locale\", \"\");\n    __publicField(this, \"_locales\");\n    __publicField(this, \"_localeData\", {});\n    __publicField(this, \"_messages\", {});\n    __publicField(this, \"_missing\");\n    __publicField(this, \"_messageCompiler\");\n    /**\n     * Alias for {@see I18n._}\n     */\n    __publicField(this, \"t\", this._.bind(this));\n    if (true) {\n      this.setMessagesCompiler(_lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_0__.compileMessage);\n    }\n    if (params.missing != null)\n      this._missing = params.missing;\n    if (params.messages != null)\n      this.load(params.messages);\n    if (params.localeData != null)\n      this.loadLocaleData(params.localeData);\n    if (typeof params.locale === \"string\" || params.locales) {\n      this.activate(params.locale ?? defaultLocale, params.locales);\n    }\n  }\n  get locale() {\n    return this._locale;\n  }\n  get locales() {\n    return this._locales;\n  }\n  get messages() {\n    return this._messages[this._locale] ?? {};\n  }\n  /**\n   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4\n   */\n  get localeData() {\n    return this._localeData[this._locale] ?? {};\n  }\n  _loadLocaleData(locale, localeData) {\n    const maybeLocaleData = this._localeData[locale];\n    if (!maybeLocaleData) {\n      this._localeData[locale] = localeData;\n    } else {\n      Object.assign(maybeLocaleData, localeData);\n    }\n  }\n  /**\n   * Registers a `MessageCompiler` to enable the use of uncompiled catalogs at runtime.\n   *\n   * In production builds, the `MessageCompiler` is typically excluded to reduce bundle size.\n   * By default, message catalogs should be precompiled during the build process. However,\n   * if you need to compile catalogs at runtime, you can use this method to set a message compiler.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * import { compileMessage } from \"@lingui/message-utils/compileMessage\";\n   *\n   * i18n.setMessagesCompiler(compileMessage);\n   * ```\n   */\n  setMessagesCompiler(compiler) {\n    this._messageCompiler = compiler;\n    return this;\n  }\n  /**\n   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4\n   */\n  loadLocaleData(localeOrAllData, localeData) {\n    if (typeof localeOrAllData === \"string\") {\n      this._loadLocaleData(localeOrAllData, localeData);\n    } else {\n      Object.keys(localeOrAllData).forEach(\n        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  _load(locale, messages) {\n    const maybeMessages = this._messages[locale];\n    if (!maybeMessages) {\n      this._messages[locale] = messages;\n    } else {\n      Object.assign(maybeMessages, messages);\n    }\n  }\n  load(localeOrMessages, messages) {\n    if (typeof localeOrMessages == \"string\" && typeof messages === \"object\") {\n      this._load(localeOrMessages, messages);\n    } else {\n      Object.entries(localeOrMessages).forEach(\n        ([locale, messages2]) => this._load(locale, messages2)\n      );\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * @param options {@link LoadAndActivateOptions}\n   */\n  loadAndActivate({ locale, locales, messages }) {\n    this._locale = locale;\n    this._locales = locales || void 0;\n    this._messages[this._locale] = messages;\n    this.emit(\"change\");\n  }\n  activate(locale, locales) {\n    if (true) {\n      if (!this._messages[locale]) {\n        console.warn(`Messages for locale \"${locale}\" not loaded.`);\n      }\n    }\n    this._locale = locale;\n    this._locales = locales;\n    this.emit(\"change\");\n  }\n  _(id, values, options) {\n    if (!this.locale) {\n      throw new Error(\n        \"Lingui: Attempted to call a translation function without setting a locale.\\nMake sure to call `i18n.activate(locale)` before using Lingui functions.\\nThis issue may also occur due to a race condition in your initialization logic.\"\n      );\n    }\n    let message = options?.message;\n    if (!id) {\n      id = \"\";\n    }\n    if (!isString(id)) {\n      values = id.values || values;\n      message = id.message;\n      id = id.id;\n    }\n    const messageForId = this.messages[id];\n    const messageMissing = messageForId === void 0;\n    const missing = this._missing;\n    if (missing && messageMissing) {\n      return isFunction(missing) ? missing(this._locale, id) : missing;\n    }\n    if (messageMissing) {\n      this.emit(\"missing\", { id, locale: this._locale });\n    }\n    let translation = messageForId || message || id;\n    if (isString(translation)) {\n      if (this._messageCompiler) {\n        translation = this._messageCompiler(translation);\n      } else {\n        console.warn(`Uncompiled message detected! Message:\n\n> ${translation}\n\nThat means you use raw catalog or your catalog doesn't have a translation for the message and fallback was used.\nICU features such as interpolation and plurals will not work properly for that message. \n\nPlease compile your catalog first. \n`);\n      }\n    }\n    if (isString(translation) && ESCAPE_SEQUENCE_REGEX.test(translation))\n      return decodeEscapeSequences(translation);\n    if (isString(translation))\n      return translation;\n    return interpolate(\n      translation,\n      this._locale,\n      this._locales\n    )(values, options?.formats);\n  }\n  date(value, format) {\n    return date(this._locales || this._locale, value, format);\n  }\n  number(value, format) {\n    return number(this._locales || this._locale, value, format);\n  }\n}\nfunction setupI18n(params = {}) {\n  return new I18n(params);\n}\n\nconst i18n = setupI18n();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNFOztBQUV0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0JBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxHQUFHLFVBQVUsR0FBRyx3QkFBd0I7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsRUFBRSxnQkFBZ0IsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxrQkFBa0IsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QywrQkFBK0IsZ0ZBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7O0FBRTBDIiwic291cmNlcyI6WyIvZGF0YS9Qcm9qZWN0cy9HYWxlb24gcHJvamVjdHMvZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXAvbWFpbi9ub2RlX21vZHVsZXMvQGxpbmd1aS9jb3JlL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXBpbGVNZXNzYWdlIH0gZnJvbSAnQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2NvbXBpbGVNZXNzYWdlJztcblxuY29uc3QgaXNTdHJpbmcgPSAocykgPT4gdHlwZW9mIHMgPT09IFwic3RyaW5nXCI7XG5jb25zdCBpc0Z1bmN0aW9uID0gKGYpID0+IHR5cGVvZiBmID09PSBcImZ1bmN0aW9uXCI7XG5cbmNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmNvbnN0IGRlZmF1bHRMb2NhbGUgPSBcImVuXCI7XG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbGVzKGxvY2FsZXMpIHtcbiAgY29uc3Qgb3V0ID0gQXJyYXkuaXNBcnJheShsb2NhbGVzKSA/IGxvY2FsZXMgOiBbbG9jYWxlc107XG4gIHJldHVybiBbLi4ub3V0LCBkZWZhdWx0TG9jYWxlXTtcbn1cbmZ1bmN0aW9uIGRhdGUobG9jYWxlcywgdmFsdWUsIGZvcm1hdCkge1xuICBjb25zdCBfbG9jYWxlcyA9IG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcyk7XG4gIGlmICghZm9ybWF0KSB7XG4gICAgZm9ybWF0ID0gXCJkZWZhdWx0XCI7XG4gIH1cbiAgbGV0IG87XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbyA9IHtcbiAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFwiZnVsbFwiOlxuICAgICAgICBvLndlZWtkYXkgPSBcImxvbmdcIjtcbiAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgIG8ubW9udGggPSBcImxvbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgICAgby5tb250aCA9IFwibnVtZXJpY1wiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbyA9IGZvcm1hdDtcbiAgfVxuICBjb25zdCBmb3JtYXR0ZXIgPSBnZXRNZW1vaXplZChcbiAgICAoKSA9PiBjYWNoZUtleShcImRhdGVcIiwgX2xvY2FsZXMsIGZvcm1hdCksXG4gICAgKCkgPT4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoX2xvY2FsZXMsIG8pXG4gICk7XG4gIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGlzU3RyaW5nKHZhbHVlKSA/IG5ldyBEYXRlKHZhbHVlKSA6IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRpbWUobG9jYWxlcywgdmFsdWUsIGZvcm1hdCkge1xuICBsZXQgbztcbiAgaWYgKCFmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSBcImRlZmF1bHRcIjtcbiAgfVxuICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIG8gPSB7XG4gICAgICBzZWNvbmQ6IFwibnVtZXJpY1wiLFxuICAgICAgbWludXRlOiBcIm51bWVyaWNcIixcbiAgICAgIGhvdXI6IFwibnVtZXJpY1wiXG4gICAgfTtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSBcImZ1bGxcIjpcbiAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgIG8udGltZVpvbmVOYW1lID0gXCJzaG9ydFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgICBkZWxldGUgby5zZWNvbmQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG8gPSBmb3JtYXQ7XG4gIH1cbiAgcmV0dXJuIGRhdGUobG9jYWxlcywgdmFsdWUsIG8pO1xufVxuZnVuY3Rpb24gbnVtYmVyKGxvY2FsZXMsIHZhbHVlLCBmb3JtYXQpIHtcbiAgY29uc3QgX2xvY2FsZXMgPSBub3JtYWxpemVMb2NhbGVzKGxvY2FsZXMpO1xuICBjb25zdCBmb3JtYXR0ZXIgPSBnZXRNZW1vaXplZChcbiAgICAoKSA9PiBjYWNoZUtleShcIm51bWJlclwiLCBfbG9jYWxlcywgZm9ybWF0KSxcbiAgICAoKSA9PiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoX2xvY2FsZXMsIGZvcm1hdClcbiAgKTtcbiAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xufVxuZnVuY3Rpb24gcGx1cmFsKGxvY2FsZXMsIG9yZGluYWwsIHZhbHVlLCB7IG9mZnNldCA9IDAsIC4uLnJ1bGVzIH0pIHtcbiAgY29uc3QgX2xvY2FsZXMgPSBub3JtYWxpemVMb2NhbGVzKGxvY2FsZXMpO1xuICBjb25zdCBwbHVyYWxzID0gb3JkaW5hbCA/IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwicGx1cmFsLW9yZGluYWxcIiwgX2xvY2FsZXMpLFxuICAgICgpID0+IG5ldyBJbnRsLlBsdXJhbFJ1bGVzKF9sb2NhbGVzLCB7IHR5cGU6IFwib3JkaW5hbFwiIH0pXG4gICkgOiBnZXRNZW1vaXplZChcbiAgICAoKSA9PiBjYWNoZUtleShcInBsdXJhbC1jYXJkaW5hbFwiLCBfbG9jYWxlcyksXG4gICAgKCkgPT4gbmV3IEludGwuUGx1cmFsUnVsZXMoX2xvY2FsZXMsIHsgdHlwZTogXCJjYXJkaW5hbFwiIH0pXG4gICk7XG4gIHJldHVybiBydWxlc1t2YWx1ZV0gPz8gcnVsZXNbcGx1cmFscy5zZWxlY3QodmFsdWUgLSBvZmZzZXQpXSA/PyBydWxlcy5vdGhlcjtcbn1cbmZ1bmN0aW9uIGdldE1lbW9pemVkKGdldEtleSwgY29uc3RydWN0KSB7XG4gIGNvbnN0IGtleSA9IGdldEtleSgpO1xuICBsZXQgZm9ybWF0dGVyID0gY2FjaGUuZ2V0KGtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gY29uc3RydWN0KCk7XG4gICAgY2FjaGUuc2V0KGtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuZnVuY3Rpb24gY2FjaGVLZXkodHlwZSwgbG9jYWxlcywgb3B0aW9ucykge1xuICBjb25zdCBsb2NhbGVLZXkgPSBsb2NhbGVzLmpvaW4oXCItXCIpO1xuICByZXR1cm4gYCR7dHlwZX0tJHtsb2NhbGVLZXl9LSR7SlNPTi5zdHJpbmdpZnkob3B0aW9ucyl9YDtcbn1cblxuY29uc3QgZm9ybWF0cyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkYXRlOiBkYXRlLFxuICBkZWZhdWx0TG9jYWxlOiBkZWZhdWx0TG9jYWxlLFxuICBudW1iZXI6IG51bWJlcixcbiAgcGx1cmFsOiBwbHVyYWwsXG4gIHRpbWU6IHRpbWVcbn07XG5cbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRV9SRUdFWCA9IC9cXFxcdVthLWZBLUYwLTldezR9fFxcXFx4W2EtZkEtRjAtOV17Mn0vO1xuY29uc3QgZGVjb2RlRXNjYXBlU2VxdWVuY2VzID0gKHN0cikgPT4ge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoXG4gICAgLy8gU2FtZSBwYXR0ZXJuIGJ1dCB3aXRoIGNhcHR1cmluZyBncm91cHMgZm9yIGV4dHJhY3RpbmcgdmFsdWVzIGR1cmluZyByZXBsYWNlbWVudFxuICAgIC9cXFxcdShbYS1mQS1GMC05XXs0fSl8XFxcXHgoW2EtZkEtRjAtOV17Mn0pL2csXG4gICAgKF8sIHVuaWNvZGUsIGhleCkgPT4ge1xuICAgICAgaWYgKHVuaWNvZGUpIHtcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gcGFyc2VJbnQodW5pY29kZSwgMTYpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICB9XG4gICAgfVxuICApO1xufTtcblxuY29uc3QgT0NUT1RIT1JQRV9QSCA9IFwiJV9fbGluZ3VpX29jdG90aG9ycGVfXyVcIjtcbmNvbnN0IGdldERlZmF1bHRGb3JtYXRzID0gKGxvY2FsZSwgcGFzc2VkTG9jYWxlcywgZm9ybWF0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxvY2FsZXMgPSBwYXNzZWRMb2NhbGVzIHx8IGxvY2FsZTtcbiAgY29uc3Qgc3R5bGUgPSAoZm9ybWF0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIHJldHVybiBmb3JtYXRzW2Zvcm1hdF07XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VPY3RvdGhvcnBlID0gKHZhbHVlLCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0ID0gT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID8gc3R5bGUoXCJudW1iZXJcIikgOiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWVTdHIgPSBudW1iZXIobG9jYWxlcywgdmFsdWUsIG51bWJlckZvcm1hdCk7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKE9DVE9USE9SUEVfUEgsIFwiZ1wiKSwgdmFsdWVTdHIpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHBsdXJhbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgZmFsc2UsIHZhbHVlLCBjYXNlcyk7XG4gICAgICByZXR1cm4gcmVwbGFjZU9jdG90aG9ycGUodmFsdWUgLSBvZmZzZXQsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgc2VsZWN0b3JkaW5hbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgdHJ1ZSwgdmFsdWUsIGNhc2VzKTtcbiAgICAgIHJldHVybiByZXBsYWNlT2N0b3Rob3JwZSh2YWx1ZSAtIG9mZnNldCwgbWVzc2FnZSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IHNlbGVjdEZvcm1hdHRlcixcbiAgICBudW1iZXI6ICh2YWx1ZSwgZm9ybWF0KSA9PiBudW1iZXIoXG4gICAgICBsb2NhbGVzLFxuICAgICAgdmFsdWUsXG4gICAgICBzdHlsZShmb3JtYXQpIHx8IHsgc3R5bGU6IGZvcm1hdCB9XG4gICAgKSxcbiAgICBkYXRlOiAodmFsdWUsIGZvcm1hdCkgPT4gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgc3R5bGUoZm9ybWF0KSB8fCBmb3JtYXQpLFxuICAgIHRpbWU6ICh2YWx1ZSwgZm9ybWF0KSA9PiB0aW1lKGxvY2FsZXMsIHZhbHVlLCBzdHlsZShmb3JtYXQpIHx8IGZvcm1hdClcbiAgfTtcbn07XG5jb25zdCBzZWxlY3RGb3JtYXR0ZXIgPSAodmFsdWUsIHJ1bGVzKSA9PiBydWxlc1t2YWx1ZV0gPz8gcnVsZXMub3RoZXI7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cmFuc2xhdGlvbiwgbG9jYWxlLCBsb2NhbGVzKSB7XG4gIHJldHVybiAodmFsdWVzID0ge30sIGZvcm1hdHMpID0+IHtcbiAgICBjb25zdCBmb3JtYXR0ZXJzID0gZ2V0RGVmYXVsdEZvcm1hdHMobG9jYWxlLCBsb2NhbGVzLCBmb3JtYXRzKTtcbiAgICBjb25zdCBmb3JtYXRNZXNzYWdlID0gKHRva2VucywgcmVwbGFjZU9jdG90aG9ycGUgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykpXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZSgobWVzc2FnZSwgdG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuID09PSBcIiNcIiAmJiByZXBsYWNlT2N0b3Rob3JwZSkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgT0NUT1RIT1JQRV9QSDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbmFtZSwgdHlwZSwgZm9ybWF0XSA9IHRva2VuO1xuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkRm9ybWF0ID0ge307XG4gICAgICAgIGlmICh0eXBlID09PSBcInBsdXJhbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0b3JkaW5hbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhmb3JtYXQpLmZvckVhY2goXG4gICAgICAgICAgICAoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRGb3JtYXRba2V5XSA9IGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIHR5cGUgPT09IFwicGx1cmFsXCIgfHwgdHlwZSA9PT0gXCJzZWxlY3RvcmRpbmFsXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlZEZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1t0eXBlXTtcbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZXNbbmFtZV0sIGludGVycG9sYXRlZEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZSArIHZhbHVlO1xuICAgICAgfSwgXCJcIik7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRNZXNzYWdlKHRyYW5zbGF0aW9uKTtcbiAgICBpZiAoaXNTdHJpbmcocmVzdWx0KSAmJiBFU0NBUEVfU0VRVUVOQ0VfUkVHRVgudGVzdChyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gZGVjb2RlRXNjYXBlU2VxdWVuY2VzKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0ID8gU3RyaW5nKHJlc3VsdCkgOiBcIlwiO1xuICB9O1xufVxuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiX2V2ZW50c1wiLCB7fSk7XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2V2ZW50cylbZXZlbnRdID8/IChfYVtldmVudF0gPSBbXSk7XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gbWF5YmVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKH5pbmRleClcbiAgICAgIG1heWJlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIG1heWJlTGlzdGVuZXJzLm1hcCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfVxuICBfZ2V0TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgY29uc3QgbWF5YmVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1heWJlTGlzdGVuZXJzKSA/IG1heWJlTGlzdGVuZXJzIDogZmFsc2U7XG4gIH1cbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgSTE4biBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVcIiwgXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbG9jYWxlRGF0YVwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tZXNzYWdlc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9taXNzaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWVzc2FnZUNvbXBpbGVyXCIpO1xuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QHNlZSBJMThuLl99XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRcIiwgdGhpcy5fLmJpbmQodGhpcykpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWlzc2luZyAhPSBudWxsKVxuICAgICAgdGhpcy5fbWlzc2luZyA9IHBhcmFtcy5taXNzaW5nO1xuICAgIGlmIChwYXJhbXMubWVzc2FnZXMgIT0gbnVsbClcbiAgICAgIHRoaXMubG9hZChwYXJhbXMubWVzc2FnZXMpO1xuICAgIGlmIChwYXJhbXMubG9jYWxlRGF0YSAhPSBudWxsKVxuICAgICAgdGhpcy5sb2FkTG9jYWxlRGF0YShwYXJhbXMubG9jYWxlRGF0YSk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubG9jYWxlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtcy5sb2NhbGVzKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKHBhcmFtcy5sb2NhbGUgPz8gZGVmYXVsdExvY2FsZSwgcGFyYW1zLmxvY2FsZXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH1cbiAgZ2V0IGxvY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZXM7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB0aGlzIGhhcyBubyBlZmZlY3QuIFBsZWFzZSByZW1vdmUgdGhpcyBmcm9tIHRoZSBjb2RlLiBEZXByZWNhdGVkIGluIHY0XG4gICAqL1xuICBnZXQgbG9jYWxlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlRGF0YVt0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIF9sb2FkTG9jYWxlRGF0YShsb2NhbGUsIGxvY2FsZURhdGEpIHtcbiAgICBjb25zdCBtYXliZUxvY2FsZURhdGEgPSB0aGlzLl9sb2NhbGVEYXRhW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZUxvY2FsZURhdGEpIHtcbiAgICAgIHRoaXMuX2xvY2FsZURhdGFbbG9jYWxlXSA9IGxvY2FsZURhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVMb2NhbGVEYXRhLCBsb2NhbGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBNZXNzYWdlQ29tcGlsZXJgIHRvIGVuYWJsZSB0aGUgdXNlIG9mIHVuY29tcGlsZWQgY2F0YWxvZ3MgYXQgcnVudGltZS5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiBidWlsZHMsIHRoZSBgTWVzc2FnZUNvbXBpbGVyYCBpcyB0eXBpY2FsbHkgZXhjbHVkZWQgdG8gcmVkdWNlIGJ1bmRsZSBzaXplLlxuICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlIGNhdGFsb2dzIHNob3VsZCBiZSBwcmVjb21waWxlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MuIEhvd2V2ZXIsXG4gICAqIGlmIHlvdSBuZWVkIHRvIGNvbXBpbGUgY2F0YWxvZ3MgYXQgcnVudGltZSwgeW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgbWVzc2FnZSBjb21waWxlci5cbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY29tcGlsZU1lc3NhZ2UgfSBmcm9tIFwiQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2NvbXBpbGVNZXNzYWdlXCI7XG4gICAqXG4gICAqIGkxOG4uc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlcikge1xuICAgIHRoaXMuX21lc3NhZ2VDb21waWxlciA9IGNvbXBpbGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBQbHVyYWxzIGF1dG9tYXRpY2FsbHkgdXNlZCBmcm9tIEludGwuUGx1cmFsUnVsZXMgeW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gRGVwcmVjYXRlZCBpbiB2NFxuICAgKi9cbiAgbG9hZExvY2FsZURhdGEobG9jYWxlT3JBbGxEYXRhLCBsb2NhbGVEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPckFsbERhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2xvYWRMb2NhbGVEYXRhKGxvY2FsZU9yQWxsRGF0YSwgbG9jYWxlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGxvY2FsZU9yQWxsRGF0YSkuZm9yRWFjaChcbiAgICAgICAgKGxvY2FsZSkgPT4gdGhpcy5fbG9hZExvY2FsZURhdGEobG9jYWxlLCBsb2NhbGVPckFsbERhdGFbbG9jYWxlXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICBfbG9hZChsb2NhbGUsIG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWF5YmVNZXNzYWdlcyA9IHRoaXMuX21lc3NhZ2VzW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZU1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlc1tsb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVNZXNzYWdlcywgbWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBsb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPck1lc3NhZ2VzID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG1lc3NhZ2VzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9sb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmVudHJpZXMobG9jYWxlT3JNZXNzYWdlcykuZm9yRWFjaChcbiAgICAgICAgKFtsb2NhbGUsIG1lc3NhZ2VzMl0pID0+IHRoaXMuX2xvYWQobG9jYWxlLCBtZXNzYWdlczIpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtAbGluayBMb2FkQW5kQWN0aXZhdGVPcHRpb25zfVxuICAgKi9cbiAgbG9hZEFuZEFjdGl2YXRlKHsgbG9jYWxlLCBsb2NhbGVzLCBtZXNzYWdlcyB9KSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX2xvY2FsZXMgPSBsb2NhbGVzIHx8IHZvaWQgMDtcbiAgICB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIGFjdGl2YXRlKGxvY2FsZSwgbG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghdGhpcy5fbWVzc2FnZXNbbG9jYWxlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE1lc3NhZ2VzIGZvciBsb2NhbGUgXCIke2xvY2FsZX1cIiBub3QgbG9hZGVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5fbG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIF8oaWQsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJMaW5ndWk6IEF0dGVtcHRlZCB0byBjYWxsIGEgdHJhbnNsYXRpb24gZnVuY3Rpb24gd2l0aG91dCBzZXR0aW5nIGEgbG9jYWxlLlxcbk1ha2Ugc3VyZSB0byBjYWxsIGBpMThuLmFjdGl2YXRlKGxvY2FsZSlgIGJlZm9yZSB1c2luZyBMaW5ndWkgZnVuY3Rpb25zLlxcblRoaXMgaXNzdWUgbWF5IGFsc28gb2NjdXIgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gaW4geW91ciBpbml0aWFsaXphdGlvbiBsb2dpYy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBvcHRpb25zPy5tZXNzYWdlO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhpZCkpIHtcbiAgICAgIHZhbHVlcyA9IGlkLnZhbHVlcyB8fCB2YWx1ZXM7XG4gICAgICBtZXNzYWdlID0gaWQubWVzc2FnZTtcbiAgICAgIGlkID0gaWQuaWQ7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VGb3JJZCA9IHRoaXMubWVzc2FnZXNbaWRdO1xuICAgIGNvbnN0IG1lc3NhZ2VNaXNzaW5nID0gbWVzc2FnZUZvcklkID09PSB2b2lkIDA7XG4gICAgY29uc3QgbWlzc2luZyA9IHRoaXMuX21pc3Npbmc7XG4gICAgaWYgKG1pc3NpbmcgJiYgbWVzc2FnZU1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG1pc3NpbmcpID8gbWlzc2luZyh0aGlzLl9sb2NhbGUsIGlkKSA6IG1pc3Npbmc7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlTWlzc2luZykge1xuICAgICAgdGhpcy5lbWl0KFwibWlzc2luZ1wiLCB7IGlkLCBsb2NhbGU6IHRoaXMuX2xvY2FsZSB9KTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0aW9uID0gbWVzc2FnZUZvcklkIHx8IG1lc3NhZ2UgfHwgaWQ7XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSkge1xuICAgICAgaWYgKHRoaXMuX21lc3NhZ2VDb21waWxlcikge1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHRoaXMuX21lc3NhZ2VDb21waWxlcih0cmFuc2xhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuY29tcGlsZWQgbWVzc2FnZSBkZXRlY3RlZCEgTWVzc2FnZTpcblxuPiAke3RyYW5zbGF0aW9ufVxuXG5UaGF0IG1lYW5zIHlvdSB1c2UgcmF3IGNhdGFsb2cgb3IgeW91ciBjYXRhbG9nIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zbGF0aW9uIGZvciB0aGUgbWVzc2FnZSBhbmQgZmFsbGJhY2sgd2FzIHVzZWQuXG5JQ1UgZmVhdHVyZXMgc3VjaCBhcyBpbnRlcnBvbGF0aW9uIGFuZCBwbHVyYWxzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkgZm9yIHRoYXQgbWVzc2FnZS4gXG5cblBsZWFzZSBjb21waWxlIHlvdXIgY2F0YWxvZyBmaXJzdC4gXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSAmJiBFU0NBUEVfU0VRVUVOQ0VfUkVHRVgudGVzdCh0cmFuc2xhdGlvbikpXG4gICAgICByZXR1cm4gZGVjb2RlRXNjYXBlU2VxdWVuY2VzKHRyYW5zbGF0aW9uKTtcbiAgICBpZiAoaXNTdHJpbmcodHJhbnNsYXRpb24pKVxuICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZShcbiAgICAgIHRyYW5zbGF0aW9uLFxuICAgICAgdGhpcy5fbG9jYWxlLFxuICAgICAgdGhpcy5fbG9jYWxlc1xuICAgICkodmFsdWVzLCBvcHRpb25zPy5mb3JtYXRzKTtcbiAgfVxuICBkYXRlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZGF0ZSh0aGlzLl9sb2NhbGVzIHx8IHRoaXMuX2xvY2FsZSwgdmFsdWUsIGZvcm1hdCk7XG4gIH1cbiAgbnVtYmVyKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gbnVtYmVyKHRoaXMuX2xvY2FsZXMgfHwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgZm9ybWF0KTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0dXBJMThuKHBhcmFtcyA9IHt9KSB7XG4gIHJldHVybiBuZXcgSTE4bihwYXJhbXMpO1xufVxuXG5jb25zdCBpMThuID0gc2V0dXBJMThuKCk7XG5cbmV4cG9ydCB7IEkxOG4sIGZvcm1hdHMsIGkxOG4sIHNldHVwSTE4biB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lingui/message-utils/dist/compileMessage.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileMessage: () => (/* binding */ compileMessage),\n/* harmony export */   compileMessageOrThrow: () => (/* binding */ compileMessageOrThrow)\n/* harmony export */ });\n/* harmony import */ var _messageformat_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @messageformat/parser */ \"(ssr)/./node_modules/@messageformat/parser/lib/parser.js\");\n\n\n/**\n * Parent class for errors.\n *\n * @remarks\n * Errors with `type: \"warning\"` do not necessarily indicate that the parser\n * encountered an error. In addition to a human-friendly `message`, may also\n * includes the `token` at which the error was encountered.\n *\n * @public\n */\nclass DateFormatError extends Error {\n    /** @internal */\n    constructor(msg, token, type) {\n        super(msg);\n        this.token = token;\n        this.type = type || 'error';\n    }\n}\nconst alpha = (width) => width < 4 ? 'short' : width === 4 ? 'long' : 'narrow';\nconst numeric = (width) => (width % 2 === 0 ? '2-digit' : 'numeric');\nfunction yearOptions(token, onError) {\n    switch (token.char) {\n        case 'y':\n            return { year: numeric(token.width) };\n        case 'r':\n            return { calendar: 'gregory', year: 'numeric' };\n        case 'u':\n        case 'U':\n        case 'Y':\n        default:\n            onError(`${token.desc} is not supported; falling back to year:numeric`, DateFormatError.WARNING);\n            return { year: 'numeric' };\n    }\n}\nfunction monthStyle(token, onError) {\n    switch (token.width) {\n        case 1:\n            return 'numeric';\n        case 2:\n            return '2-digit';\n        case 3:\n            return 'short';\n        case 4:\n            return 'long';\n        case 5:\n            return 'narrow';\n        default:\n            onError(`${token.desc} is not supported with width ${token.width}`);\n            return undefined;\n    }\n}\nfunction dayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if (char === 'd') {\n        return numeric(width);\n    }\n    else {\n        onError(`${desc} is not supported`);\n        return undefined;\n    }\n}\nfunction weekdayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if ((char === 'c' || char === 'e') && width < 3) {\n        // ignoring stand-alone-ness\n        const msg = `Numeric value is not supported for ${desc}; falling back to weekday:short`;\n        onError(msg, DateFormatError.WARNING);\n    }\n    // merging narrow styles\n    return alpha(width);\n}\nfunction hourOptions(token) {\n    const hour = numeric(token.width);\n    let hourCycle;\n    switch (token.char) {\n        case 'h':\n            hourCycle = 'h12';\n            break;\n        case 'H':\n            hourCycle = 'h23';\n            break;\n        case 'k':\n            hourCycle = 'h24';\n            break;\n        case 'K':\n            hourCycle = 'h11';\n            break;\n    }\n    return hourCycle ? { hour, hourCycle } : { hour };\n}\nfunction timeZoneNameStyle(token, onError) {\n    // so much fallback behaviour here\n    const { char, desc, width } = token;\n    switch (char) {\n        case 'v':\n        case 'z':\n            return width === 4 ? 'long' : 'short';\n        case 'V':\n            if (width === 4)\n                return 'long';\n            onError(`${desc} is not supported with width ${width}`);\n            return undefined;\n        case 'X':\n            onError(`${desc} is not supported`);\n            return undefined;\n    }\n    return 'short';\n}\nfunction compileOptions(token, onError) {\n    switch (token.field) {\n        case 'era':\n            return { era: alpha(token.width) };\n        case 'year':\n            return yearOptions(token, onError);\n        case 'month':\n            return { month: monthStyle(token, onError) };\n        case 'day':\n            return { day: dayStyle(token, onError) };\n        case 'weekday':\n            return { weekday: weekdayStyle(token, onError) };\n        case 'period':\n            return undefined;\n        case 'hour':\n            return hourOptions(token);\n        case 'min':\n            return { minute: numeric(token.width) };\n        case 'sec':\n            return { second: numeric(token.width) };\n        case 'tz':\n            return { timeZoneName: timeZoneNameStyle(token, onError) };\n        case 'quarter':\n        case 'week':\n        case 'sec-frac':\n        case 'ms':\n            onError(`${token.desc} is not supported`);\n    }\n    return undefined;\n}\nfunction getDateFormatOptions(tokens, timeZone, onError = error => {\n    throw error;\n}) {\n    const options = {\n        timeZone\n    };\n    const fields = [];\n    for (const token of tokens) {\n        const { error, field, str } = token;\n        if (error) {\n            const dte = new DateFormatError(error.message, token);\n            dte.stack = error.stack;\n            onError(dte);\n        }\n        if (str) {\n            const msg = `Ignoring string part: ${str}`;\n            onError(new DateFormatError(msg, token, DateFormatError.WARNING));\n        }\n        if (field) {\n            if (fields.indexOf(field) === -1)\n                fields.push(field);\n            else\n                onError(new DateFormatError(`Duplicate ${field} token`, token));\n        }\n        const opt = compileOptions(token, (msg, isWarning) => onError(new DateFormatError(msg, token, isWarning)));\n        if (opt)\n            Object.assign(options, opt);\n    }\n    return options;\n}\n\nconst fields = {\n    G: { field: 'era', desc: 'Era' },\n    y: { field: 'year', desc: 'Year' },\n    Y: { field: 'year', desc: 'Year of \"Week of Year\"' },\n    u: { field: 'year', desc: 'Extended year' },\n    U: { field: 'year', desc: 'Cyclic year name' },\n    r: { field: 'year', desc: 'Related Gregorian year' },\n    Q: { field: 'quarter', desc: 'Quarter' },\n    q: { field: 'quarter', desc: 'Stand-alone quarter' },\n    M: { field: 'month', desc: 'Month in year' },\n    L: { field: 'month', desc: 'Stand-alone month in year' },\n    w: { field: 'week', desc: 'Week of year' },\n    W: { field: 'week', desc: 'Week of month' },\n    d: { field: 'day', desc: 'Day in month' },\n    D: { field: 'day', desc: 'Day of year' },\n    F: { field: 'day', desc: 'Day of week in month' },\n    g: { field: 'day', desc: 'Modified julian day' },\n    E: { field: 'weekday', desc: 'Day of week' },\n    e: { field: 'weekday', desc: 'Local day of week' },\n    c: { field: 'weekday', desc: 'Stand-alone local day of week' },\n    a: { field: 'period', desc: 'AM/PM marker' },\n    b: { field: 'period', desc: 'AM/PM/noon/midnight marker' },\n    B: { field: 'period', desc: 'Flexible day period' },\n    h: { field: 'hour', desc: 'Hour in AM/PM (1~12)' },\n    H: { field: 'hour', desc: 'Hour in day (0~23)' },\n    k: { field: 'hour', desc: 'Hour in day (1~24)' },\n    K: { field: 'hour', desc: 'Hour in AM/PM (0~11)' },\n    j: { field: 'hour', desc: 'Hour in preferred cycle' },\n    J: { field: 'hour', desc: 'Hour in preferred cycle without marker' },\n    C: { field: 'hour', desc: 'Hour in preferred cycle with flexible marker' },\n    m: { field: 'min', desc: 'Minute in hour' },\n    s: { field: 'sec', desc: 'Second in minute' },\n    S: { field: 'sec-frac', desc: 'Fractional second' },\n    A: { field: 'ms', desc: 'Milliseconds in day' },\n    z: { field: 'tz', desc: 'Time Zone: specific non-location' },\n    Z: { field: 'tz', desc: 'Time Zone' },\n    O: { field: 'tz', desc: 'Time Zone: localized' },\n    v: { field: 'tz', desc: 'Time Zone: generic non-location' },\n    V: { field: 'tz', desc: 'Time Zone: ID' },\n    X: { field: 'tz', desc: 'Time Zone: ISO8601 with Z' },\n    x: { field: 'tz', desc: 'Time Zone: ISO8601' }\n};\nconst isLetter = (char) => (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');\nfunction readFieldToken(src, pos) {\n    const char = src[pos];\n    let width = 1;\n    while (src[++pos] === char)\n        ++width;\n    const field = fields[char];\n    if (!field) {\n        const msg = `The letter ${char} is not a valid field identifier`;\n        return { char, error: new Error(msg), width };\n    }\n    return { char, field: field.field, desc: field.desc, width };\n}\nfunction readQuotedToken(src, pos) {\n    let str = src[++pos];\n    let width = 2;\n    if (str === \"'\")\n        return { char: \"'\", str, width };\n    while (true) {\n        const next = src[++pos];\n        ++width;\n        if (next === undefined) {\n            const msg = `Unterminated quoted literal in pattern: ${str || src}`;\n            return { char: \"'\", error: new Error(msg), str, width };\n        }\n        else if (next === \"'\") {\n            if (src[++pos] !== \"'\")\n                return { char: \"'\", str, width };\n            else\n                ++width;\n        }\n        str += next;\n    }\n}\nfunction readToken(src, pos) {\n    const char = src[pos];\n    if (!char)\n        return null;\n    if (isLetter(char))\n        return readFieldToken(src, pos);\n    if (char === \"'\")\n        return readQuotedToken(src, pos);\n    let str = char;\n    let width = 1;\n    while (true) {\n        const next = src[++pos];\n        if (!next || isLetter(next) || next === \"'\")\n            return { char, str, width };\n        str += next;\n        width += 1;\n    }\n}\n/**\n * Parse an {@link http://userguide.icu-project.org/formatparse/datetime | ICU\n * DateFormat skeleton} string into a {@link DateToken} array.\n *\n * @remarks\n * Errors will not be thrown, but if encountered are included as the relevant\n * token's `error` value.\n *\n * @public\n * @param src - The skeleton string\n *\n * @example\n * ```js\n * import { parseDateTokens } from '@messageformat/date-skeleton'\n *\n * parseDateTokens('GrMMMdd', console.error)\n * // [\n * //   { char: 'G', field: 'era', desc: 'Era', width: 1 },\n * //   { char: 'r', field: 'year', desc: 'Related Gregorian year', width: 1 },\n * //   { char: 'M', field: 'month', desc: 'Month in year', width: 3 },\n * //   { char: 'd', field: 'day', desc: 'Day in month', width: 2 }\n * // ]\n * ```\n */\nfunction parseDateTokens(src) {\n    const tokens = [];\n    let pos = 0;\n    while (true) {\n        const token = readToken(src, pos);\n        if (!token)\n            return tokens;\n        tokens.push(token);\n        pos += token.width;\n    }\n}\n\nfunction processTokens(tokens, mapText) {\n  if (!tokens.filter((token) => token.type !== \"content\").length) {\n    return tokens.map((token) => mapText(token.value));\n  }\n  return tokens.map((token) => {\n    if (token.type === \"content\") {\n      return mapText(token.value);\n    } else if (token.type === \"octothorpe\") {\n      return \"#\";\n    } else if (token.type === \"argument\") {\n      return [token.arg];\n    } else if (token.type === \"function\") {\n      const _param = token?.param?.[0];\n      if (token.key === \"date\" && _param) {\n        const opts = compileDateExpression(_param.value.trim(), (e) => {\n          throw new Error(`Unable to compile date expression: ${e.message}`);\n        });\n        return [token.arg, token.key, opts];\n      }\n      if (_param) {\n        return [token.arg, token.key, _param.value.trim()];\n      } else {\n        return [token.arg, token.key];\n      }\n    }\n    const offset = token.pluralOffset;\n    const formatProps = {};\n    token.cases.forEach(({ key, tokens: tokens2 }) => {\n      const prop = key[0] === \"=\" ? key.slice(1) : key;\n      formatProps[prop] = processTokens(tokens2, mapText);\n    });\n    return [\n      token.arg,\n      token.type,\n      {\n        offset,\n        ...formatProps\n      }\n    ];\n  });\n}\nfunction compileDateExpression(format, onError) {\n  if (/^::/.test(format)) {\n    const tokens = parseDateTokens(format.substring(2));\n    return getDateFormatOptions(tokens, void 0, onError);\n  }\n  return format;\n}\nfunction compileMessageOrThrow(message, mapText = (v) => v) {\n  return processTokens((0,_messageformat_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(message), mapText);\n}\nfunction compileMessage(message, mapText = (v) => v) {\n  try {\n    return compileMessageOrThrow(message, mapText);\n  } catch (e) {\n    console.error(`${e.message} \n\nMessage: ${message}`);\n    return [message];\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2Rpc3QvY29tcGlsZU1lc3NhZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZLGtCQUFrQjtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksOEJBQThCLFlBQVk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQixJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU0sOEJBQThCLE1BQU07QUFDakU7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFx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QTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7O0FBRXJCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRWlEIiwic291cmNlcyI6WyIvZGF0YS9Qcm9qZWN0cy9HYWxlb24gcHJvamVjdHMvZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXAvbWFpbi9ub2RlX21vZHVsZXMvQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2Rpc3QvY29tcGlsZU1lc3NhZ2UubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlIH0gZnJvbSAnQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyJztcblxuLyoqXG4gKiBQYXJlbnQgY2xhc3MgZm9yIGVycm9ycy5cbiAqXG4gKiBAcmVtYXJrc1xuICogRXJyb3JzIHdpdGggYHR5cGU6IFwid2FybmluZ1wiYCBkbyBub3QgbmVjZXNzYXJpbHkgaW5kaWNhdGUgdGhhdCB0aGUgcGFyc2VyXG4gKiBlbmNvdW50ZXJlZCBhbiBlcnJvci4gSW4gYWRkaXRpb24gdG8gYSBodW1hbi1mcmllbmRseSBgbWVzc2FnZWAsIG1heSBhbHNvXG4gKiBpbmNsdWRlcyB0aGUgYHRva2VuYCBhdCB3aGljaCB0aGUgZXJyb3Igd2FzIGVuY291bnRlcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRGF0ZUZvcm1hdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBjb25zdHJ1Y3Rvcihtc2csIHRva2VuLCB0eXBlKSB7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCAnZXJyb3InO1xuICAgIH1cbn1cbmNvbnN0IGFscGhhID0gKHdpZHRoKSA9PiB3aWR0aCA8IDQgPyAnc2hvcnQnIDogd2lkdGggPT09IDQgPyAnbG9uZycgOiAnbmFycm93JztcbmNvbnN0IG51bWVyaWMgPSAod2lkdGgpID0+ICh3aWR0aCAlIDIgPT09IDAgPyAnMi1kaWdpdCcgOiAnbnVtZXJpYycpO1xuZnVuY3Rpb24geWVhck9wdGlvbnModG9rZW4sIG9uRXJyb3IpIHtcbiAgICBzd2l0Y2ggKHRva2VuLmNoYXIpIHtcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICByZXR1cm4geyB5ZWFyOiBudW1lcmljKHRva2VuLndpZHRoKSB9O1xuICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHJldHVybiB7IGNhbGVuZGFyOiAnZ3JlZ29yeScsIHllYXI6ICdudW1lcmljJyB9O1xuICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgIGNhc2UgJ1knOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb25FcnJvcihgJHt0b2tlbi5kZXNjfSBpcyBub3Qgc3VwcG9ydGVkOyBmYWxsaW5nIGJhY2sgdG8geWVhcjpudW1lcmljYCwgRGF0ZUZvcm1hdEVycm9yLldBUk5JTkcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxufVxuZnVuY3Rpb24gbW9udGhTdHlsZSh0b2tlbiwgb25FcnJvcikge1xuICAgIHN3aXRjaCAodG9rZW4ud2lkdGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuICdudW1lcmljJztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuICcyLWRpZ2l0JztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuICdzaG9ydCc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiAnbG9uZyc7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiAnbmFycm93JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG9uRXJyb3IoYCR7dG9rZW4uZGVzY30gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHdpZHRoICR7dG9rZW4ud2lkdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRheVN0eWxlKHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBjaGFyLCBkZXNjLCB3aWR0aCB9ID0gdG9rZW47XG4gICAgaWYgKGNoYXIgPT09ICdkJykge1xuICAgICAgICByZXR1cm4gbnVtZXJpYyh3aWR0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvbkVycm9yKGAke2Rlc2N9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiB3ZWVrZGF5U3R5bGUodG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IGNoYXIsIGRlc2MsIHdpZHRoIH0gPSB0b2tlbjtcbiAgICBpZiAoKGNoYXIgPT09ICdjJyB8fCBjaGFyID09PSAnZScpICYmIHdpZHRoIDwgMykge1xuICAgICAgICAvLyBpZ25vcmluZyBzdGFuZC1hbG9uZS1uZXNzXG4gICAgICAgIGNvbnN0IG1zZyA9IGBOdW1lcmljIHZhbHVlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yICR7ZGVzY307IGZhbGxpbmcgYmFjayB0byB3ZWVrZGF5OnNob3J0YDtcbiAgICAgICAgb25FcnJvcihtc2csIERhdGVGb3JtYXRFcnJvci5XQVJOSU5HKTtcbiAgICB9XG4gICAgLy8gbWVyZ2luZyBuYXJyb3cgc3R5bGVzXG4gICAgcmV0dXJuIGFscGhhKHdpZHRoKTtcbn1cbmZ1bmN0aW9uIGhvdXJPcHRpb25zKHRva2VuKSB7XG4gICAgY29uc3QgaG91ciA9IG51bWVyaWModG9rZW4ud2lkdGgpO1xuICAgIGxldCBob3VyQ3ljbGU7XG4gICAgc3dpdGNoICh0b2tlbi5jaGFyKSB7XG4gICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgaG91ckN5Y2xlID0gJ2gxMic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICBob3VyQ3ljbGUgPSAnaDIzJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdrJzpcbiAgICAgICAgICAgIGhvdXJDeWNsZSA9ICdoMjQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgaG91ckN5Y2xlID0gJ2gxMSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGhvdXJDeWNsZSA/IHsgaG91ciwgaG91ckN5Y2xlIH0gOiB7IGhvdXIgfTtcbn1cbmZ1bmN0aW9uIHRpbWVab25lTmFtZVN0eWxlKHRva2VuLCBvbkVycm9yKSB7XG4gICAgLy8gc28gbXVjaCBmYWxsYmFjayBiZWhhdmlvdXIgaGVyZVxuICAgIGNvbnN0IHsgY2hhciwgZGVzYywgd2lkdGggfSA9IHRva2VuO1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPT09IDQgPyAnbG9uZycgOiAnc2hvcnQnO1xuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gNClcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2xvbmcnO1xuICAgICAgICAgICAgb25FcnJvcihgJHtkZXNjfSBpcyBub3Qgc3VwcG9ydGVkIHdpdGggd2lkdGggJHt3aWR0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgb25FcnJvcihgJHtkZXNjfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gJ3Nob3J0Jztcbn1cbmZ1bmN0aW9uIGNvbXBpbGVPcHRpb25zKHRva2VuLCBvbkVycm9yKSB7XG4gICAgc3dpdGNoICh0b2tlbi5maWVsZCkge1xuICAgICAgICBjYXNlICdlcmEnOlxuICAgICAgICAgICAgcmV0dXJuIHsgZXJhOiBhbHBoYSh0b2tlbi53aWR0aCkgfTtcbiAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICByZXR1cm4geWVhck9wdGlvbnModG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICByZXR1cm4geyBtb250aDogbW9udGhTdHlsZSh0b2tlbiwgb25FcnJvcikgfTtcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHJldHVybiB7IGRheTogZGF5U3R5bGUodG9rZW4sIG9uRXJyb3IpIH07XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICAgICAgcmV0dXJuIHsgd2Vla2RheTogd2Vla2RheVN0eWxlKHRva2VuLCBvbkVycm9yKSB9O1xuICAgICAgICBjYXNlICdwZXJpb2QnOlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICByZXR1cm4gaG91ck9wdGlvbnModG9rZW4pO1xuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgcmV0dXJuIHsgbWludXRlOiBudW1lcmljKHRva2VuLndpZHRoKSB9O1xuICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICAgICAgcmV0dXJuIHsgc2Vjb25kOiBudW1lcmljKHRva2VuLndpZHRoKSB9O1xuICAgICAgICBjYXNlICd0eic6XG4gICAgICAgICAgICByZXR1cm4geyB0aW1lWm9uZU5hbWU6IHRpbWVab25lTmFtZVN0eWxlKHRva2VuLCBvbkVycm9yKSB9O1xuICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ3NlYy1mcmFjJzpcbiAgICAgICAgY2FzZSAnbXMnOlxuICAgICAgICAgICAgb25FcnJvcihgJHt0b2tlbi5kZXNjfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXREYXRlRm9ybWF0T3B0aW9ucyh0b2tlbnMsIHRpbWVab25lLCBvbkVycm9yID0gZXJyb3IgPT4ge1xuICAgIHRocm93IGVycm9yO1xufSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHRpbWVab25lXG4gICAgfTtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBjb25zdCB7IGVycm9yLCBmaWVsZCwgc3RyIH0gPSB0b2tlbjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBkdGUgPSBuZXcgRGF0ZUZvcm1hdEVycm9yKGVycm9yLm1lc3NhZ2UsIHRva2VuKTtcbiAgICAgICAgICAgIGR0ZS5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgICAgICAgICAgb25FcnJvcihkdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBJZ25vcmluZyBzdHJpbmcgcGFydDogJHtzdHJ9YDtcbiAgICAgICAgICAgIG9uRXJyb3IobmV3IERhdGVGb3JtYXRFcnJvcihtc2csIHRva2VuLCBEYXRlRm9ybWF0RXJyb3IuV0FSTklORykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgaWYgKGZpZWxkcy5pbmRleE9mKGZpZWxkKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IERhdGVGb3JtYXRFcnJvcihgRHVwbGljYXRlICR7ZmllbGR9IHRva2VuYCwgdG9rZW4pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBjb21waWxlT3B0aW9ucyh0b2tlbiwgKG1zZywgaXNXYXJuaW5nKSA9PiBvbkVycm9yKG5ldyBEYXRlRm9ybWF0RXJyb3IobXNnLCB0b2tlbiwgaXNXYXJuaW5nKSkpO1xuICAgICAgICBpZiAob3B0KVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBvcHQpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxuY29uc3QgZmllbGRzID0ge1xuICAgIEc6IHsgZmllbGQ6ICdlcmEnLCBkZXNjOiAnRXJhJyB9LFxuICAgIHk6IHsgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ1llYXInIH0sXG4gICAgWTogeyBmaWVsZDogJ3llYXInLCBkZXNjOiAnWWVhciBvZiBcIldlZWsgb2YgWWVhclwiJyB9LFxuICAgIHU6IHsgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ0V4dGVuZGVkIHllYXInIH0sXG4gICAgVTogeyBmaWVsZDogJ3llYXInLCBkZXNjOiAnQ3ljbGljIHllYXIgbmFtZScgfSxcbiAgICByOiB7IGZpZWxkOiAneWVhcicsIGRlc2M6ICdSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyJyB9LFxuICAgIFE6IHsgZmllbGQ6ICdxdWFydGVyJywgZGVzYzogJ1F1YXJ0ZXInIH0sXG4gICAgcTogeyBmaWVsZDogJ3F1YXJ0ZXInLCBkZXNjOiAnU3RhbmQtYWxvbmUgcXVhcnRlcicgfSxcbiAgICBNOiB7IGZpZWxkOiAnbW9udGgnLCBkZXNjOiAnTW9udGggaW4geWVhcicgfSxcbiAgICBMOiB7IGZpZWxkOiAnbW9udGgnLCBkZXNjOiAnU3RhbmQtYWxvbmUgbW9udGggaW4geWVhcicgfSxcbiAgICB3OiB7IGZpZWxkOiAnd2VlaycsIGRlc2M6ICdXZWVrIG9mIHllYXInIH0sXG4gICAgVzogeyBmaWVsZDogJ3dlZWsnLCBkZXNjOiAnV2VlayBvZiBtb250aCcgfSxcbiAgICBkOiB7IGZpZWxkOiAnZGF5JywgZGVzYzogJ0RheSBpbiBtb250aCcgfSxcbiAgICBEOiB7IGZpZWxkOiAnZGF5JywgZGVzYzogJ0RheSBvZiB5ZWFyJyB9LFxuICAgIEY6IHsgZmllbGQ6ICdkYXknLCBkZXNjOiAnRGF5IG9mIHdlZWsgaW4gbW9udGgnIH0sXG4gICAgZzogeyBmaWVsZDogJ2RheScsIGRlc2M6ICdNb2RpZmllZCBqdWxpYW4gZGF5JyB9LFxuICAgIEU6IHsgZmllbGQ6ICd3ZWVrZGF5JywgZGVzYzogJ0RheSBvZiB3ZWVrJyB9LFxuICAgIGU6IHsgZmllbGQ6ICd3ZWVrZGF5JywgZGVzYzogJ0xvY2FsIGRheSBvZiB3ZWVrJyB9LFxuICAgIGM6IHsgZmllbGQ6ICd3ZWVrZGF5JywgZGVzYzogJ1N0YW5kLWFsb25lIGxvY2FsIGRheSBvZiB3ZWVrJyB9LFxuICAgIGE6IHsgZmllbGQ6ICdwZXJpb2QnLCBkZXNjOiAnQU0vUE0gbWFya2VyJyB9LFxuICAgIGI6IHsgZmllbGQ6ICdwZXJpb2QnLCBkZXNjOiAnQU0vUE0vbm9vbi9taWRuaWdodCBtYXJrZXInIH0sXG4gICAgQjogeyBmaWVsZDogJ3BlcmlvZCcsIGRlc2M6ICdGbGV4aWJsZSBkYXkgcGVyaW9kJyB9LFxuICAgIGg6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gQU0vUE0gKDF+MTIpJyB9LFxuICAgIEg6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gZGF5ICgwfjIzKScgfSxcbiAgICBrOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIGRheSAoMX4yNCknIH0sXG4gICAgSzogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBBTS9QTSAoMH4xMSknIH0sXG4gICAgajogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBwcmVmZXJyZWQgY3ljbGUnIH0sXG4gICAgSjogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBwcmVmZXJyZWQgY3ljbGUgd2l0aG91dCBtYXJrZXInIH0sXG4gICAgQzogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBwcmVmZXJyZWQgY3ljbGUgd2l0aCBmbGV4aWJsZSBtYXJrZXInIH0sXG4gICAgbTogeyBmaWVsZDogJ21pbicsIGRlc2M6ICdNaW51dGUgaW4gaG91cicgfSxcbiAgICBzOiB7IGZpZWxkOiAnc2VjJywgZGVzYzogJ1NlY29uZCBpbiBtaW51dGUnIH0sXG4gICAgUzogeyBmaWVsZDogJ3NlYy1mcmFjJywgZGVzYzogJ0ZyYWN0aW9uYWwgc2Vjb25kJyB9LFxuICAgIEE6IHsgZmllbGQ6ICdtcycsIGRlc2M6ICdNaWxsaXNlY29uZHMgaW4gZGF5JyB9LFxuICAgIHo6IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IHNwZWNpZmljIG5vbi1sb2NhdGlvbicgfSxcbiAgICBaOiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lJyB9LFxuICAgIE86IHsgZmllbGQ6ICd0eicsIGRlc2M6ICdUaW1lIFpvbmU6IGxvY2FsaXplZCcgfSxcbiAgICB2OiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBnZW5lcmljIG5vbi1sb2NhdGlvbicgfSxcbiAgICBWOiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBJRCcgfSxcbiAgICBYOiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBJU084NjAxIHdpdGggWicgfSxcbiAgICB4OiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBJU084NjAxJyB9XG59O1xuY29uc3QgaXNMZXR0ZXIgPSAoY2hhcikgPT4gKGNoYXIgPj0gJ0EnICYmIGNoYXIgPD0gJ1onKSB8fCAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAneicpO1xuZnVuY3Rpb24gcmVhZEZpZWxkVG9rZW4oc3JjLCBwb3MpIHtcbiAgICBjb25zdCBjaGFyID0gc3JjW3Bvc107XG4gICAgbGV0IHdpZHRoID0gMTtcbiAgICB3aGlsZSAoc3JjWysrcG9zXSA9PT0gY2hhcilcbiAgICAgICAgKyt3aWR0aDtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tjaGFyXTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgbGV0dGVyICR7Y2hhcn0gaXMgbm90IGEgdmFsaWQgZmllbGQgaWRlbnRpZmllcmA7XG4gICAgICAgIHJldHVybiB7IGNoYXIsIGVycm9yOiBuZXcgRXJyb3IobXNnKSwgd2lkdGggfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2hhciwgZmllbGQ6IGZpZWxkLmZpZWxkLCBkZXNjOiBmaWVsZC5kZXNjLCB3aWR0aCB9O1xufVxuZnVuY3Rpb24gcmVhZFF1b3RlZFRva2VuKHNyYywgcG9zKSB7XG4gICAgbGV0IHN0ciA9IHNyY1srK3Bvc107XG4gICAgbGV0IHdpZHRoID0gMjtcbiAgICBpZiAoc3RyID09PSBcIidcIilcbiAgICAgICAgcmV0dXJuIHsgY2hhcjogXCInXCIsIHN0ciwgd2lkdGggfTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gc3JjWysrcG9zXTtcbiAgICAgICAgKyt3aWR0aDtcbiAgICAgICAgaWYgKG5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVudGVybWluYXRlZCBxdW90ZWQgbGl0ZXJhbCBpbiBwYXR0ZXJuOiAke3N0ciB8fCBzcmN9YDtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXI6IFwiJ1wiLCBlcnJvcjogbmV3IEVycm9yKG1zZyksIHN0ciwgd2lkdGggfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXh0ID09PSBcIidcIikge1xuICAgICAgICAgICAgaWYgKHNyY1srK3Bvc10gIT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYXI6IFwiJ1wiLCBzdHIsIHdpZHRoIH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKyt3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gbmV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkVG9rZW4oc3JjLCBwb3MpIHtcbiAgICBjb25zdCBjaGFyID0gc3JjW3Bvc107XG4gICAgaWYgKCFjaGFyKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaXNMZXR0ZXIoY2hhcikpXG4gICAgICAgIHJldHVybiByZWFkRmllbGRUb2tlbihzcmMsIHBvcyk7XG4gICAgaWYgKGNoYXIgPT09IFwiJ1wiKVxuICAgICAgICByZXR1cm4gcmVhZFF1b3RlZFRva2VuKHNyYywgcG9zKTtcbiAgICBsZXQgc3RyID0gY2hhcjtcbiAgICBsZXQgd2lkdGggPSAxO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBzcmNbKytwb3NdO1xuICAgICAgICBpZiAoIW5leHQgfHwgaXNMZXR0ZXIobmV4dCkgfHwgbmV4dCA9PT0gXCInXCIpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFyLCBzdHIsIHdpZHRoIH07XG4gICAgICAgIHN0ciArPSBuZXh0O1xuICAgICAgICB3aWR0aCArPSAxO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgYW4ge0BsaW5rIGh0dHA6Ly91c2VyZ3VpZGUuaWN1LXByb2plY3Qub3JnL2Zvcm1hdHBhcnNlL2RhdGV0aW1lIHwgSUNVXG4gKiBEYXRlRm9ybWF0IHNrZWxldG9ufSBzdHJpbmcgaW50byBhIHtAbGluayBEYXRlVG9rZW59IGFycmF5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBFcnJvcnMgd2lsbCBub3QgYmUgdGhyb3duLCBidXQgaWYgZW5jb3VudGVyZWQgYXJlIGluY2x1ZGVkIGFzIHRoZSByZWxldmFudFxuICogdG9rZW4ncyBgZXJyb3JgIHZhbHVlLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBzcmMgLSBUaGUgc2tlbGV0b24gc3RyaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBwYXJzZURhdGVUb2tlbnMgfSBmcm9tICdAbWVzc2FnZWZvcm1hdC9kYXRlLXNrZWxldG9uJ1xuICpcbiAqIHBhcnNlRGF0ZVRva2VucygnR3JNTU1kZCcsIGNvbnNvbGUuZXJyb3IpXG4gKiAvLyBbXG4gKiAvLyAgIHsgY2hhcjogJ0cnLCBmaWVsZDogJ2VyYScsIGRlc2M6ICdFcmEnLCB3aWR0aDogMSB9LFxuICogLy8gICB7IGNoYXI6ICdyJywgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ1JlbGF0ZWQgR3JlZ29yaWFuIHllYXInLCB3aWR0aDogMSB9LFxuICogLy8gICB7IGNoYXI6ICdNJywgZmllbGQ6ICdtb250aCcsIGRlc2M6ICdNb250aCBpbiB5ZWFyJywgd2lkdGg6IDMgfSxcbiAqIC8vICAgeyBjaGFyOiAnZCcsIGZpZWxkOiAnZGF5JywgZGVzYzogJ0RheSBpbiBtb250aCcsIHdpZHRoOiAyIH1cbiAqIC8vIF1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBwYXJzZURhdGVUb2tlbnMoc3JjKSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSByZWFkVG9rZW4oc3JjLCBwb3MpO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICBwb3MgKz0gdG9rZW4ud2lkdGg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVG9rZW5zKHRva2VucywgbWFwVGV4dCkge1xuICBpZiAoIXRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiB0b2tlbi50eXBlICE9PSBcImNvbnRlbnRcIikubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuKSA9PiBtYXBUZXh0KHRva2VuLnZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwiY29udGVudFwiKSB7XG4gICAgICByZXR1cm4gbWFwVGV4dCh0b2tlbi52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBcIm9jdG90aG9ycGVcIikge1xuICAgICAgcmV0dXJuIFwiI1wiO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gXCJhcmd1bWVudFwiKSB7XG4gICAgICByZXR1cm4gW3Rva2VuLmFyZ107XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IF9wYXJhbSA9IHRva2VuPy5wYXJhbT8uWzBdO1xuICAgICAgaWYgKHRva2VuLmtleSA9PT0gXCJkYXRlXCIgJiYgX3BhcmFtKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBjb21waWxlRGF0ZUV4cHJlc3Npb24oX3BhcmFtLnZhbHVlLnRyaW0oKSwgKGUpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb21waWxlIGRhdGUgZXhwcmVzc2lvbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW3Rva2VuLmFyZywgdG9rZW4ua2V5LCBvcHRzXTtcbiAgICAgIH1cbiAgICAgIGlmIChfcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIFt0b2tlbi5hcmcsIHRva2VuLmtleSwgX3BhcmFtLnZhbHVlLnRyaW0oKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3Rva2VuLmFyZywgdG9rZW4ua2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4ucGx1cmFsT2Zmc2V0O1xuICAgIGNvbnN0IGZvcm1hdFByb3BzID0ge307XG4gICAgdG9rZW4uY2FzZXMuZm9yRWFjaCgoeyBrZXksIHRva2VuczogdG9rZW5zMiB9KSA9PiB7XG4gICAgICBjb25zdCBwcm9wID0ga2V5WzBdID09PSBcIj1cIiA/IGtleS5zbGljZSgxKSA6IGtleTtcbiAgICAgIGZvcm1hdFByb3BzW3Byb3BdID0gcHJvY2Vzc1Rva2Vucyh0b2tlbnMyLCBtYXBUZXh0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgdG9rZW4uYXJnLFxuICAgICAgdG9rZW4udHlwZSxcbiAgICAgIHtcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICAuLi5mb3JtYXRQcm9wc1xuICAgICAgfVxuICAgIF07XG4gIH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZURhdGVFeHByZXNzaW9uKGZvcm1hdCwgb25FcnJvcikge1xuICBpZiAoL146Oi8udGVzdChmb3JtYXQpKSB7XG4gICAgY29uc3QgdG9rZW5zID0gcGFyc2VEYXRlVG9rZW5zKGZvcm1hdC5zdWJzdHJpbmcoMikpO1xuICAgIHJldHVybiBnZXREYXRlRm9ybWF0T3B0aW9ucyh0b2tlbnMsIHZvaWQgMCwgb25FcnJvcik7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVNZXNzYWdlT3JUaHJvdyhtZXNzYWdlLCBtYXBUZXh0ID0gKHYpID0+IHYpIHtcbiAgcmV0dXJuIHByb2Nlc3NUb2tlbnMocGFyc2UobWVzc2FnZSksIG1hcFRleHQpO1xufVxuZnVuY3Rpb24gY29tcGlsZU1lc3NhZ2UobWVzc2FnZSwgbWFwVGV4dCA9ICh2KSA9PiB2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbXBpbGVNZXNzYWdlT3JUaHJvdyhtZXNzYWdlLCBtYXBUZXh0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYCR7ZS5tZXNzYWdlfSBcblxuTWVzc2FnZTogJHttZXNzYWdlfWApO1xuICAgIHJldHVybiBbbWVzc2FnZV07XG4gIH1cbn1cblxuZXhwb3J0IHsgY29tcGlsZU1lc3NhZ2UsIGNvbXBpbGVNZXNzYWdlT3JUaHJvdyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@lingui/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nProvider: () => (/* binding */ I18nProvider),\n/* harmony export */   LinguiContext: () => (/* binding */ LinguiContext),\n/* harmony export */   Trans: () => (/* binding */ Trans),\n/* harmony export */   useLingui: () => (/* binding */ useLingui)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shared_react_31c3b5fa_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/react.31c3b5fa.mjs */ \"(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs\");\n/* __next_internal_client_entry_do_not_use__ I18nProvider,LinguiContext,Trans,useLingui auto */ \n\nconst LinguiContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useLinguiInternal = (devErrorMessage)=>{\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LinguiContext);\n    if (true) {\n        if (context == null) {\n            throw new Error(devErrorMessage ?? \"useLingui hook was used without I18nProvider.\");\n        }\n    }\n    return context;\n};\nfunction useLingui() {\n    return useLinguiInternal();\n}\nfunction I18nProvider({ i18n, defaultComponent, children }) {\n    const latestKnownLocale = react__WEBPACK_IMPORTED_MODULE_0__.useRef(i18n.locale);\n    const makeContext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"I18nProvider.useCallback[makeContext]\": ()=>({\n                i18n,\n                defaultComponent,\n                _: i18n.t.bind(i18n)\n            })\n    }[\"I18nProvider.useCallback[makeContext]\"], [\n        i18n,\n        defaultComponent\n    ]);\n    const [context, setContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState(makeContext());\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"I18nProvider.useEffect\": ()=>{\n            const updateContext = {\n                \"I18nProvider.useEffect.updateContext\": ()=>{\n                    latestKnownLocale.current = i18n.locale;\n                    setContext(makeContext());\n                }\n            }[\"I18nProvider.useEffect.updateContext\"];\n            const unsubscribe = i18n.on(\"change\", updateContext);\n            if (latestKnownLocale.current !== i18n.locale) {\n                updateContext();\n            }\n            return unsubscribe;\n        }\n    }[\"I18nProvider.useEffect\"], [\n        i18n,\n        makeContext\n    ]);\n    if (!latestKnownLocale.current) {\n         true && console.log(\"I18nProvider rendered `null`. A call to `i18n.activate` needs to happen in order for translations to be activated and for the I18nProvider to render.This is not an error but an informational message logged only in development.\");\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinguiContext.Provider, {\n        value: context\n    }, children);\n}\nfunction Trans(props) {\n    let errMessage = void 0;\n    if (true) {\n        errMessage = `Trans component was rendered without I18nProvider.\nAttempted to render message: ${props.message} id: ${props.id}. Make sure this component is rendered inside a I18nProvider.`;\n    }\n    const lingui = useLinguiInternal(errMessage);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shared_react_31c3b5fa_mjs__WEBPACK_IMPORTED_MODULE_1__.T, {\n        ...props,\n        lingui\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Z0dBQzBCO0FBQ3dDO0FBRWxFLE1BQU1HLDhCQUFnQkgsZ0RBQW1CLENBQUM7QUFDMUMsTUFBTUssb0JBQW9CLENBQUNDO0lBQ3pCLE1BQU1DLFVBQVVQLDZDQUFnQixDQUFDRztJQUNqQyxJQUFJTSxJQUFxQyxFQUFFO1FBQ3pDLElBQUlGLFdBQVcsTUFBTTtZQUNuQixNQUFNLElBQUlHLE1BQ1JKLG1CQUFtQjtRQUV2QjtJQUNGO0lBQ0EsT0FBT0M7QUFDVDtBQUNBLFNBQVNJO0lBQ1AsT0FBT047QUFDVDtBQUNBLFNBQVNPLGFBQWEsRUFDcEJDLElBQUksRUFDSkMsZ0JBQWdCLEVBQ2hCQyxRQUFRLEVBQ1Q7SUFDQyxNQUFNQyxvQkFBb0JoQix5Q0FBWSxDQUFDYSxLQUFLSyxNQUFNO0lBQ2xELE1BQU1DLGNBQWNuQiw4Q0FBaUI7aURBQ25DLElBQU87Z0JBQ0xhO2dCQUNBQztnQkFDQU8sR0FBR1IsS0FBS1MsQ0FBQyxDQUFDQyxJQUFJLENBQUNWO1lBQ2pCO2dEQUNBO1FBQUNBO1FBQU1DO0tBQWlCO0lBRTFCLE1BQU0sQ0FBQ1AsU0FBU2lCLFdBQVcsR0FBR3hCLDJDQUFjLENBQUNtQjtJQUM3Q25CLDRDQUFlO2tDQUFDO1lBQ2QsTUFBTTJCO3dEQUFnQjtvQkFDcEJYLGtCQUFrQlksT0FBTyxHQUFHZixLQUFLSyxNQUFNO29CQUN2Q00sV0FBV0w7Z0JBQ2I7O1lBQ0EsTUFBTVUsY0FBY2hCLEtBQUtpQixFQUFFLENBQUMsVUFBVUg7WUFDdEMsSUFBSVgsa0JBQWtCWSxPQUFPLEtBQUtmLEtBQUtLLE1BQU0sRUFBRTtnQkFDN0NTO1lBQ0Y7WUFDQSxPQUFPRTtRQUNUO2lDQUFHO1FBQUNoQjtRQUFNTTtLQUFZO0lBQ3RCLElBQUksQ0FBQ0gsa0JBQWtCWSxPQUFPLEVBQUU7UUFUZCxLQVVzQixJQUFJRyxRQUFRQyxHQUFHLENBQ25EO1FBRUYsT0FBTztJQUNUO0lBQ0EsT0FBTyxhQUFhLGlCQUFHaEMsZ0RBQW1CLENBQUNHLGNBQWMrQixRQUFRLEVBQUU7UUFBRUMsT0FBTzVCO0lBQVEsR0FBR1E7QUFDekY7QUFFQSxTQUFTcUIsTUFBTUMsS0FBSztJQUNsQixJQUFJQyxhQUFhLEtBQUs7SUFDdEIsSUFBSTdCLElBQXFDLEVBQUU7UUFDekM2QixhQUFhLENBQUM7NkJBQ1csRUFBRUQsTUFBTUUsT0FBTyxDQUFDLEtBQUssRUFBRUYsTUFBTUcsRUFBRSxDQUFDLDZEQUE2RCxDQUFDO0lBQ3pIO0lBQ0EsTUFBTUMsU0FBU3BDLGtCQUFrQmlDO0lBQ2pDLHFCQUFPdEMsZ0RBQW1CLENBQUNFLHlEQUFjQSxFQUFFO1FBQUUsR0FBR21DLEtBQUs7UUFBRUk7SUFBTztBQUNoRTtBQUV5RCIsInNvdXJjZXMiOlsiL2RhdGEvUHJvamVjdHMvR2FsZW9uIHByb2plY3RzL2dhbGVvbi1jb21tdW5pdHktaG9zcGl0YWwtbWFwL21haW4vbm9kZV9tb2R1bGVzL0BsaW5ndWkvcmVhY3QvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFQgYXMgVHJhbnNOb0NvbnRleHQgfSBmcm9tICcuL3NoYXJlZC9yZWFjdC4zMWMzYjVmYS5tanMnO1xuXG5jb25zdCBMaW5ndWlDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHVzZUxpbmd1aUludGVybmFsID0gKGRldkVycm9yTWVzc2FnZSkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMaW5ndWlDb250ZXh0KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZGV2RXJyb3JNZXNzYWdlID8/IFwidXNlTGluZ3VpIGhvb2sgd2FzIHVzZWQgd2l0aG91dCBJMThuUHJvdmlkZXIuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcbmZ1bmN0aW9uIHVzZUxpbmd1aSgpIHtcbiAgcmV0dXJuIHVzZUxpbmd1aUludGVybmFsKCk7XG59XG5mdW5jdGlvbiBJMThuUHJvdmlkZXIoe1xuICBpMThuLFxuICBkZWZhdWx0Q29tcG9uZW50LFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBsYXRlc3RLbm93bkxvY2FsZSA9IFJlYWN0LnVzZVJlZihpMThuLmxvY2FsZSk7XG4gIGNvbnN0IG1ha2VDb250ZXh0ID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gKHtcbiAgICAgIGkxOG4sXG4gICAgICBkZWZhdWx0Q29tcG9uZW50LFxuICAgICAgXzogaTE4bi50LmJpbmQoaTE4bilcbiAgICB9KSxcbiAgICBbaTE4biwgZGVmYXVsdENvbXBvbmVudF1cbiAgKTtcbiAgY29uc3QgW2NvbnRleHQsIHNldENvbnRleHRdID0gUmVhY3QudXNlU3RhdGUobWFrZUNvbnRleHQoKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlQ29udGV4dCA9ICgpID0+IHtcbiAgICAgIGxhdGVzdEtub3duTG9jYWxlLmN1cnJlbnQgPSBpMThuLmxvY2FsZTtcbiAgICAgIHNldENvbnRleHQobWFrZUNvbnRleHQoKSk7XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGkxOG4ub24oXCJjaGFuZ2VcIiwgdXBkYXRlQ29udGV4dCk7XG4gICAgaWYgKGxhdGVzdEtub3duTG9jYWxlLmN1cnJlbnQgIT09IGkxOG4ubG9jYWxlKSB7XG4gICAgICB1cGRhdGVDb250ZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSwgW2kxOG4sIG1ha2VDb250ZXh0XSk7XG4gIGlmICghbGF0ZXN0S25vd25Mb2NhbGUuY3VycmVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIgJiYgY29uc29sZS5sb2coXG4gICAgICBcIkkxOG5Qcm92aWRlciByZW5kZXJlZCBgbnVsbGAuIEEgY2FsbCB0byBgaTE4bi5hY3RpdmF0ZWAgbmVlZHMgdG8gaGFwcGVuIGluIG9yZGVyIGZvciB0cmFuc2xhdGlvbnMgdG8gYmUgYWN0aXZhdGVkIGFuZCBmb3IgdGhlIEkxOG5Qcm92aWRlciB0byByZW5kZXIuVGhpcyBpcyBub3QgYW4gZXJyb3IgYnV0IGFuIGluZm9ybWF0aW9uYWwgbWVzc2FnZSBsb2dnZWQgb25seSBpbiBkZXZlbG9wbWVudC5cIlxuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KExpbmd1aUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBUcmFucyhwcm9wcykge1xuICBsZXQgZXJyTWVzc2FnZSA9IHZvaWQgMDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVyck1lc3NhZ2UgPSBgVHJhbnMgY29tcG9uZW50IHdhcyByZW5kZXJlZCB3aXRob3V0IEkxOG5Qcm92aWRlci5cbkF0dGVtcHRlZCB0byByZW5kZXIgbWVzc2FnZTogJHtwcm9wcy5tZXNzYWdlfSBpZDogJHtwcm9wcy5pZH0uIE1ha2Ugc3VyZSB0aGlzIGNvbXBvbmVudCBpcyByZW5kZXJlZCBpbnNpZGUgYSBJMThuUHJvdmlkZXIuYDtcbiAgfVxuICBjb25zdCBsaW5ndWkgPSB1c2VMaW5ndWlJbnRlcm5hbChlcnJNZXNzYWdlKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNOb0NvbnRleHQsIHsgLi4ucHJvcHMsIGxpbmd1aSB9KTtcbn1cblxuZXhwb3J0IHsgSTE4blByb3ZpZGVyLCBMaW5ndWlDb250ZXh0LCBUcmFucywgdXNlTGluZ3VpIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJUIiwiVHJhbnNOb0NvbnRleHQiLCJMaW5ndWlDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInVzZUxpbmd1aUludGVybmFsIiwiZGV2RXJyb3JNZXNzYWdlIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJwcm9jZXNzIiwiRXJyb3IiLCJ1c2VMaW5ndWkiLCJJMThuUHJvdmlkZXIiLCJpMThuIiwiZGVmYXVsdENvbXBvbmVudCIsImNoaWxkcmVuIiwibGF0ZXN0S25vd25Mb2NhbGUiLCJ1c2VSZWYiLCJsb2NhbGUiLCJtYWtlQ29udGV4dCIsInVzZUNhbGxiYWNrIiwiXyIsInQiLCJiaW5kIiwic2V0Q29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXBkYXRlQ29udGV4dCIsImN1cnJlbnQiLCJ1bnN1YnNjcmliZSIsIm9uIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwiVHJhbnMiLCJwcm9wcyIsImVyck1lc3NhZ2UiLCJtZXNzYWdlIiwiaWQiLCJsaW5ndWkiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ TransNoContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst tagRe = /<([a-zA-Z0-9]+)>([\\s\\S]*?)<\\/\\1>|<([a-zA-Z0-9]+)\\/>/;\nconst voidElementTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true,\n  menuitem: true\n};\nfunction formatElements(value, elements = {}) {\n  const uniqueId = makeCounter(0, \"$lingui$\");\n  const parts = value.split(tagRe);\n  if (parts.length === 1)\n    return value;\n  const tree = [];\n  const before = parts.shift();\n  if (before)\n    tree.push(before);\n  for (const [index, children, after] of getElements(parts)) {\n    let element = typeof index !== \"undefined\" ? elements[index] : void 0;\n    if (!element || voidElementTags[element.type] && children) {\n      if (!element) {\n        console.error(\n          `Can't use element at index '${index}' as it is not declared in the original translation`\n        );\n      } else {\n        console.error(\n          `${element.type} is a void element tag therefore it must have no children`\n        );\n      }\n      element = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment);\n    }\n    if (Array.isArray(element)) {\n      element = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, element);\n    }\n    tree.push(\n      react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(\n        element,\n        { key: uniqueId() },\n        // format children for pair tags\n        // unpaired tags might have children if it's a component passed as a variable\n        children ? formatElements(children, elements) : element.props.children\n      )\n    );\n    if (after)\n      tree.push(after);\n  }\n  return tree.length === 1 ? tree[0] : tree;\n}\nfunction getElements(parts) {\n  if (!parts.length)\n    return [];\n  const [paired, children, unpaired, after] = parts.slice(0, 4);\n  const triple = [paired || unpaired, children || \"\", after];\n  return [triple].concat(getElements(parts.slice(4, parts.length)));\n}\nconst makeCounter = (count = 0, prefix = \"\") => () => `${prefix}_${count++}`;\n\nfunction TransNoContext(props) {\n  const {\n    render,\n    component,\n    id,\n    message,\n    formats,\n    lingui: { i18n, defaultComponent }\n  } = props;\n  const values = { ...props.values };\n  const components = { ...props.components };\n  if (values) {\n    Object.keys(values).forEach((key) => {\n      const index = Object.keys(components).length;\n      if (typeof values[key] === \"string\" || typeof values[key] === \"number\") {\n        return;\n      }\n      components[index] = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, values[key]);\n      values[key] = `<${index}/>`;\n    });\n  }\n  const _translation = i18n && typeof i18n._ === \"function\" ? i18n._(id, values, { message, formats }) : id;\n  const translation = _translation ? formatElements(_translation, components) : null;\n  if (render === null || component === null) {\n    return translation;\n  }\n  const FallbackComponent = defaultComponent || RenderFragment;\n  const i18nProps = {\n    id,\n    message,\n    translation,\n    children: translation\n    // for type-compatibility with `component` prop\n  };\n  if (render && component) {\n    console.error(\n      \"You can't use both `component` and `render` prop at the same time. `component` is ignored.\"\n    );\n  } else if (render && typeof render !== \"function\") {\n    console.error(\n      `Invalid value supplied to prop \\`render\\`. It must be a function, provided ${render}`\n    );\n  } else if (component && typeof component !== \"function\") {\n    console.error(\n      `Invalid value supplied to prop \\`component\\`. It must be a React component, provided ${component}`\n    );\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, i18nProps, translation);\n  }\n  if (typeof render === \"function\") {\n    return render(i18nProps);\n  }\n  const Component = component || FallbackComponent;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, i18nProps, translation);\n}\nconst RenderFragment = ({ children }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9yZWFjdC9kaXN0L3NoYXJlZC9yZWFjdC4zMWMzYjVmYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQSxRQUFRO0FBQ1I7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsQ0FBQywyQ0FBYztBQUNsRDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFtQixDQUFDLDJDQUFjLElBQUk7QUFDdEQ7QUFDQTtBQUNBLE1BQU0sK0NBQWtCO0FBQ3hCO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLEdBQUcsUUFBUTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsSUFBSTtBQUNKLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdEQUFtQixDQUFDLDJDQUFjO0FBQzVFLHdCQUF3QixNQUFNO0FBQzlCLEtBQUs7QUFDTDtBQUNBLG1GQUFtRixrQkFBa0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvRkFBb0YsT0FBTztBQUMzRjtBQUNBLElBQUk7QUFDSjtBQUNBLDhGQUE4RixVQUFVO0FBQ3hHO0FBQ0EsV0FBVyxnREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQW1CO0FBQzVCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEMseUJBQXlCLGdEQUFtQixDQUFDLDJDQUFjO0FBQzNEOztBQUUrQiIsInNvdXJjZXMiOlsiL2RhdGEvUHJvamVjdHMvR2FsZW9uIHByb2plY3RzL2dhbGVvbi1jb21tdW5pdHktaG9zcGl0YWwtbWFwL21haW4vbm9kZV9tb2R1bGVzL0BsaW5ndWkvcmVhY3QvZGlzdC9zaGFyZWQvcmVhY3QuMzFjM2I1ZmEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHRhZ1JlID0gLzwoW2EtekEtWjAtOV0rKT4oW1xcc1xcU10qPyk8XFwvXFwxPnw8KFthLXpBLVowLTldKylcXC8+LztcbmNvbnN0IHZvaWRFbGVtZW50VGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUsXG4gIG1lbnVpdGVtOiB0cnVlXG59O1xuZnVuY3Rpb24gZm9ybWF0RWxlbWVudHModmFsdWUsIGVsZW1lbnRzID0ge30pIHtcbiAgY29uc3QgdW5pcXVlSWQgPSBtYWtlQ291bnRlcigwLCBcIiRsaW5ndWkkXCIpO1xuICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KHRhZ1JlKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHRyZWUgPSBbXTtcbiAgY29uc3QgYmVmb3JlID0gcGFydHMuc2hpZnQoKTtcbiAgaWYgKGJlZm9yZSlcbiAgICB0cmVlLnB1c2goYmVmb3JlKTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkcmVuLCBhZnRlcl0gb2YgZ2V0RWxlbWVudHMocGFydHMpKSB7XG4gICAgbGV0IGVsZW1lbnQgPSB0eXBlb2YgaW5kZXggIT09IFwidW5kZWZpbmVkXCIgPyBlbGVtZW50c1tpbmRleF0gOiB2b2lkIDA7XG4gICAgaWYgKCFlbGVtZW50IHx8IHZvaWRFbGVtZW50VGFnc1tlbGVtZW50LnR5cGVdICYmIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQ2FuJ3QgdXNlIGVsZW1lbnQgYXQgaW5kZXggJyR7aW5kZXh9JyBhcyBpdCBpcyBub3QgZGVjbGFyZWQgaW4gdGhlIG9yaWdpbmFsIHRyYW5zbGF0aW9uYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgJHtlbGVtZW50LnR5cGV9IGlzIGEgdm9pZCBlbGVtZW50IHRhZyB0aGVyZWZvcmUgaXQgbXVzdCBoYXZlIG5vIGNoaWxkcmVuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHt9LCBlbGVtZW50KTtcbiAgICB9XG4gICAgdHJlZS5wdXNoKFxuICAgICAgUmVhY3QuY2xvbmVFbGVtZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICB7IGtleTogdW5pcXVlSWQoKSB9LFxuICAgICAgICAvLyBmb3JtYXQgY2hpbGRyZW4gZm9yIHBhaXIgdGFnc1xuICAgICAgICAvLyB1bnBhaXJlZCB0YWdzIG1pZ2h0IGhhdmUgY2hpbGRyZW4gaWYgaXQncyBhIGNvbXBvbmVudCBwYXNzZWQgYXMgYSB2YXJpYWJsZVxuICAgICAgICBjaGlsZHJlbiA/IGZvcm1hdEVsZW1lbnRzKGNoaWxkcmVuLCBlbGVtZW50cykgOiBlbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgICBpZiAoYWZ0ZXIpXG4gICAgICB0cmVlLnB1c2goYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB0cmVlLmxlbmd0aCA9PT0gMSA/IHRyZWVbMF0gOiB0cmVlO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHMocGFydHMpIHtcbiAgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBbcGFpcmVkLCBjaGlsZHJlbiwgdW5wYWlyZWQsIGFmdGVyXSA9IHBhcnRzLnNsaWNlKDAsIDQpO1xuICBjb25zdCB0cmlwbGUgPSBbcGFpcmVkIHx8IHVucGFpcmVkLCBjaGlsZHJlbiB8fCBcIlwiLCBhZnRlcl07XG4gIHJldHVybiBbdHJpcGxlXS5jb25jYXQoZ2V0RWxlbWVudHMocGFydHMuc2xpY2UoNCwgcGFydHMubGVuZ3RoKSkpO1xufVxuY29uc3QgbWFrZUNvdW50ZXIgPSAoY291bnQgPSAwLCBwcmVmaXggPSBcIlwiKSA9PiAoKSA9PiBgJHtwcmVmaXh9XyR7Y291bnQrK31gO1xuXG5mdW5jdGlvbiBUcmFuc05vQ29udGV4dChwcm9wcykge1xuICBjb25zdCB7XG4gICAgcmVuZGVyLFxuICAgIGNvbXBvbmVudCxcbiAgICBpZCxcbiAgICBtZXNzYWdlLFxuICAgIGZvcm1hdHMsXG4gICAgbGluZ3VpOiB7IGkxOG4sIGRlZmF1bHRDb21wb25lbnQgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHZhbHVlcyA9IHsgLi4ucHJvcHMudmFsdWVzIH07XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7IC4uLnByb3BzLmNvbXBvbmVudHMgfTtcbiAgaWYgKHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpLmxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlc1trZXldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHNbaW5kZXhdID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHZhbHVlc1trZXldKTtcbiAgICAgIHZhbHVlc1trZXldID0gYDwke2luZGV4fS8+YDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBfdHJhbnNsYXRpb24gPSBpMThuICYmIHR5cGVvZiBpMThuLl8gPT09IFwiZnVuY3Rpb25cIiA/IGkxOG4uXyhpZCwgdmFsdWVzLCB7IG1lc3NhZ2UsIGZvcm1hdHMgfSkgOiBpZDtcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb24gPyBmb3JtYXRFbGVtZW50cyhfdHJhbnNsYXRpb24sIGNvbXBvbmVudHMpIDogbnVsbDtcbiAgaWYgKHJlbmRlciA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gIH1cbiAgY29uc3QgRmFsbGJhY2tDb21wb25lbnQgPSBkZWZhdWx0Q29tcG9uZW50IHx8IFJlbmRlckZyYWdtZW50O1xuICBjb25zdCBpMThuUHJvcHMgPSB7XG4gICAgaWQsXG4gICAgbWVzc2FnZSxcbiAgICB0cmFuc2xhdGlvbixcbiAgICBjaGlsZHJlbjogdHJhbnNsYXRpb25cbiAgICAvLyBmb3IgdHlwZS1jb21wYXRpYmlsaXR5IHdpdGggYGNvbXBvbmVudGAgcHJvcFxuICB9O1xuICBpZiAocmVuZGVyICYmIGNvbXBvbmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIllvdSBjYW4ndCB1c2UgYm90aCBgY29tcG9uZW50YCBhbmQgYHJlbmRlcmAgcHJvcCBhdCB0aGUgc2FtZSB0aW1lLiBgY29tcG9uZW50YCBpcyBpZ25vcmVkLlwiXG4gICAgKTtcbiAgfSBlbHNlIGlmIChyZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIHRvIHByb3AgXFxgcmVuZGVyXFxgLiBJdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHByb3ZpZGVkICR7cmVuZGVyfWBcbiAgICApO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgc3VwcGxpZWQgdG8gcHJvcCBcXGBjb21wb25lbnRcXGAuIEl0IG11c3QgYmUgYSBSZWFjdCBjb21wb25lbnQsIHByb3ZpZGVkICR7Y29tcG9uZW50fWBcbiAgICApO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBpMThuUHJvcHMsIHRyYW5zbGF0aW9uKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHJlbmRlcihpMThuUHJvcHMpO1xuICB9XG4gIGNvbnN0IENvbXBvbmVudCA9IGNvbXBvbmVudCB8fCBGYWxsYmFja0NvbXBvbmVudDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBpMThuUHJvcHMsIHRyYW5zbGF0aW9uKTtcbn1cbmNvbnN0IFJlbmRlckZyYWdtZW50ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydCB7IFRyYW5zTm9Db250ZXh0IGFzIFQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs\n");

/***/ })

};
;