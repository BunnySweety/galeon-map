"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lingui";
exports.ids = ["vendor-chunks/@lingui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lingui/core/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/@lingui/core/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18n: () => (/* binding */ I18n),\n/* harmony export */   formats: () => (/* binding */ formats),\n/* harmony export */   i18n: () => (/* binding */ i18n),\n/* harmony export */   setupI18n: () => (/* binding */ setupI18n)\n/* harmony export */ });\n/* harmony import */ var unraw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unraw */ \"(ssr)/./node_modules/unraw/dist/index.js\");\n/* harmony import */ var _lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lingui/message-utils/compileMessage */ \"(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs\");\n\n\n\nconst isString = (s) => typeof s === \"string\";\nconst isFunction = (f) => typeof f === \"function\";\n\nconst cache = /* @__PURE__ */ new Map();\nconst defaultLocale = \"en\";\nfunction normalizeLocales(locales) {\n  const out = Array.isArray(locales) ? locales : [locales];\n  return [...out, defaultLocale];\n}\nfunction date(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  if (!format) {\n    format = \"default\";\n  }\n  let o;\n  if (typeof format === \"string\") {\n    o = {\n      day: \"numeric\",\n      month: \"short\",\n      year: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n        o.weekday = \"long\";\n      case \"long\":\n        o.month = \"long\";\n        break;\n      case \"short\":\n        o.month = \"numeric\";\n        break;\n    }\n  } else {\n    o = format;\n  }\n  const formatter = getMemoized(\n    () => cacheKey(\"date\", _locales, format),\n    () => new Intl.DateTimeFormat(_locales, o)\n  );\n  return formatter.format(isString(value) ? new Date(value) : value);\n}\nfunction time(locales, value, format) {\n  let o;\n  if (!format) {\n    format = \"default\";\n  }\n  if (typeof format === \"string\") {\n    o = {\n      second: \"numeric\",\n      minute: \"numeric\",\n      hour: \"numeric\"\n    };\n    switch (format) {\n      case \"full\":\n      case \"long\":\n        o.timeZoneName = \"short\";\n        break;\n      case \"short\":\n        delete o.second;\n    }\n  } else {\n    o = format;\n  }\n  return date(locales, value, o);\n}\nfunction number(locales, value, format) {\n  const _locales = normalizeLocales(locales);\n  const formatter = getMemoized(\n    () => cacheKey(\"number\", _locales, format),\n    () => new Intl.NumberFormat(_locales, format)\n  );\n  return formatter.format(value);\n}\nfunction plural(locales, ordinal, value, { offset = 0, ...rules }) {\n  const _locales = normalizeLocales(locales);\n  const plurals = ordinal ? getMemoized(\n    () => cacheKey(\"plural-ordinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"ordinal\" })\n  ) : getMemoized(\n    () => cacheKey(\"plural-cardinal\", _locales),\n    () => new Intl.PluralRules(_locales, { type: \"cardinal\" })\n  );\n  return rules[value] ?? rules[plurals.select(value - offset)] ?? rules.other;\n}\nfunction getMemoized(getKey, construct) {\n  const key = getKey();\n  let formatter = cache.get(key);\n  if (!formatter) {\n    formatter = construct();\n    cache.set(key, formatter);\n  }\n  return formatter;\n}\nfunction cacheKey(type, locales, options) {\n  const localeKey = locales.join(\"-\");\n  return `${type}-${localeKey}-${JSON.stringify(options)}`;\n}\n\nconst formats = {\n  __proto__: null,\n  date: date,\n  defaultLocale: defaultLocale,\n  number: number,\n  plural: plural,\n  time: time\n};\n\nconst UNICODE_REGEX = /\\\\u[a-fA-F0-9]{4}|\\\\x[a-fA-F0-9]{2}/;\nconst OCTOTHORPE_PH = \"%__lingui_octothorpe__%\";\nconst getDefaultFormats = (locale, passedLocales, formats = {}) => {\n  const locales = passedLocales || locale;\n  const style = (format) => {\n    if (typeof format === \"object\")\n      return format;\n    return formats[format];\n  };\n  const replaceOctothorpe = (value, message) => {\n    const numberFormat = Object.keys(formats).length ? style(\"number\") : void 0;\n    const valueStr = number(locales, value, numberFormat);\n    return message.replace(new RegExp(OCTOTHORPE_PH, \"g\"), valueStr);\n  };\n  return {\n    plural: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, false, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    selectordinal: (value, cases) => {\n      const { offset = 0 } = cases;\n      const message = plural(locales, true, value, cases);\n      return replaceOctothorpe(value - offset, message);\n    },\n    select: selectFormatter,\n    number: (value, format) => number(\n      locales,\n      value,\n      style(format) || { style: format }\n    ),\n    date: (value, format) => date(locales, value, style(format) || format),\n    time: (value, format) => time(locales, value, style(format) || format)\n  };\n};\nconst selectFormatter = (value, rules) => rules[value] ?? rules.other;\nfunction interpolate(translation, locale, locales) {\n  return (values = {}, formats) => {\n    const formatters = getDefaultFormats(locale, locales, formats);\n    const formatMessage = (tokens, replaceOctothorpe = false) => {\n      if (!Array.isArray(tokens))\n        return tokens;\n      return tokens.reduce((message, token) => {\n        if (token === \"#\" && replaceOctothorpe) {\n          return message + OCTOTHORPE_PH;\n        }\n        if (isString(token)) {\n          return message + token;\n        }\n        const [name, type, format] = token;\n        let interpolatedFormat = {};\n        if (type === \"plural\" || type === \"selectordinal\" || type === \"select\") {\n          Object.entries(format).forEach(\n            ([key, value2]) => {\n              interpolatedFormat[key] = formatMessage(\n                value2,\n                type === \"plural\" || type === \"selectordinal\"\n              );\n            }\n          );\n        } else {\n          interpolatedFormat = format;\n        }\n        let value;\n        if (type) {\n          const formatter = formatters[type];\n          value = formatter(values[name], interpolatedFormat);\n        } else {\n          value = values[name];\n        }\n        if (value == null) {\n          return message;\n        }\n        return message + value;\n      }, \"\");\n    };\n    const result = formatMessage(translation);\n    if (isString(result) && UNICODE_REGEX.test(result)) {\n      return (0,unraw__WEBPACK_IMPORTED_MODULE_0__.unraw)(result);\n    }\n    if (isString(result))\n      return result;\n    return result ? String(result) : \"\";\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventEmitter {\n  constructor() {\n    __publicField$1(this, \"_events\", {});\n  }\n  on(event, listener) {\n    var _a;\n    (_a = this._events)[event] ?? (_a[event] = []);\n    this._events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n  removeListener(event, listener) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    const index = maybeListeners.indexOf(listener);\n    if (~index)\n      maybeListeners.splice(index, 1);\n  }\n  emit(event, ...args) {\n    const maybeListeners = this._getListeners(event);\n    if (!maybeListeners)\n      return;\n    maybeListeners.map((listener) => listener.apply(this, args));\n  }\n  _getListeners(event) {\n    const maybeListeners = this._events[event];\n    return Array.isArray(maybeListeners) ? maybeListeners : false;\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass I18n extends EventEmitter {\n  constructor(params) {\n    super();\n    __publicField(this, \"_locale\", \"\");\n    __publicField(this, \"_locales\");\n    __publicField(this, \"_localeData\", {});\n    __publicField(this, \"_messages\", {});\n    __publicField(this, \"_missing\");\n    __publicField(this, \"_messageCompiler\");\n    /**\n     * Alias for {@see I18n._}\n     */\n    __publicField(this, \"t\", this._.bind(this));\n    if (true) {\n      this.setMessagesCompiler(_lingui_message_utils_compileMessage__WEBPACK_IMPORTED_MODULE_1__.compileMessage);\n    }\n    if (params.missing != null)\n      this._missing = params.missing;\n    if (params.messages != null)\n      this.load(params.messages);\n    if (params.localeData != null)\n      this.loadLocaleData(params.localeData);\n    if (typeof params.locale === \"string\" || params.locales) {\n      this.activate(params.locale ?? defaultLocale, params.locales);\n    }\n  }\n  get locale() {\n    return this._locale;\n  }\n  get locales() {\n    return this._locales;\n  }\n  get messages() {\n    return this._messages[this._locale] ?? {};\n  }\n  /**\n   * @deprecated this has no effect. Please remove this from the code. Deprecated in v4\n   */\n  get localeData() {\n    return this._localeData[this._locale] ?? {};\n  }\n  _loadLocaleData(locale, localeData) {\n    const maybeLocaleData = this._localeData[locale];\n    if (!maybeLocaleData) {\n      this._localeData[locale] = localeData;\n    } else {\n      Object.assign(maybeLocaleData, localeData);\n    }\n  }\n  /**\n   * Registers a `MessageCompiler` to enable the use of uncompiled catalogs at runtime.\n   *\n   * In production builds, the `MessageCompiler` is typically excluded to reduce bundle size.\n   * By default, message catalogs should be precompiled during the build process. However,\n   * if you need to compile catalogs at runtime, you can use this method to set a message compiler.\n   *\n   * Example usage:\n   *\n   * ```ts\n   * import { compileMessage } from \"@lingui/message-utils/compileMessage\";\n   *\n   * i18n.setMessagesCompiler(compileMessage);\n   * ```\n   */\n  setMessagesCompiler(compiler) {\n    this._messageCompiler = compiler;\n    return this;\n  }\n  /**\n   * @deprecated Plurals automatically used from Intl.PluralRules you can safely remove this call. Deprecated in v4\n   */\n  loadLocaleData(localeOrAllData, localeData) {\n    if (typeof localeOrAllData === \"string\") {\n      this._loadLocaleData(localeOrAllData, localeData);\n    } else {\n      Object.keys(localeOrAllData).forEach(\n        (locale) => this._loadLocaleData(locale, localeOrAllData[locale])\n      );\n    }\n    this.emit(\"change\");\n  }\n  _load(locale, messages) {\n    const maybeMessages = this._messages[locale];\n    if (!maybeMessages) {\n      this._messages[locale] = messages;\n    } else {\n      Object.assign(maybeMessages, messages);\n    }\n  }\n  load(localeOrMessages, messages) {\n    if (typeof localeOrMessages == \"string\" && typeof messages === \"object\") {\n      this._load(localeOrMessages, messages);\n    } else {\n      Object.entries(localeOrMessages).forEach(\n        ([locale, messages2]) => this._load(locale, messages2)\n      );\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * @param options {@link LoadAndActivateOptions}\n   */\n  loadAndActivate({ locale, locales, messages }) {\n    this._locale = locale;\n    this._locales = locales || void 0;\n    this._messages[this._locale] = messages;\n    this.emit(\"change\");\n  }\n  activate(locale, locales) {\n    if (true) {\n      if (!this._messages[locale]) {\n        console.warn(`Messages for locale \"${locale}\" not loaded.`);\n      }\n    }\n    this._locale = locale;\n    this._locales = locales;\n    this.emit(\"change\");\n  }\n  _(id, values, options) {\n    if (!this.locale) {\n      throw new Error(\n        \"Lingui: Attempted to call a translation function without setting a locale.\\nMake sure to call `i18n.activate(locale)` before using Lingui functions.\\nThis issue may also occur due to a race condition in your initialization logic.\"\n      );\n    }\n    let message = options?.message;\n    if (!id) {\n      id = \"\";\n    }\n    if (!isString(id)) {\n      values = id.values || values;\n      message = id.message;\n      id = id.id;\n    }\n    const messageForId = this.messages[id];\n    const messageMissing = messageForId === void 0;\n    const missing = this._missing;\n    if (missing && messageMissing) {\n      return isFunction(missing) ? missing(this._locale, id) : missing;\n    }\n    if (messageMissing) {\n      this.emit(\"missing\", { id, locale: this._locale });\n    }\n    let translation = messageForId || message || id;\n    if (isString(translation)) {\n      if (this._messageCompiler) {\n        translation = this._messageCompiler(translation);\n      } else {\n        console.warn(`Uncompiled message detected! Message:\n\n> ${translation}\n\nThat means you use raw catalog or your catalog doesn't have a translation for the message and fallback was used.\nICU features such as interpolation and plurals will not work properly for that message. \n\nPlease compile your catalog first. \n`);\n      }\n    }\n    if (isString(translation) && UNICODE_REGEX.test(translation))\n      return JSON.parse(`\"${translation}\"`);\n    if (isString(translation))\n      return translation;\n    return interpolate(\n      translation,\n      this._locale,\n      this._locales\n    )(values, options?.formats);\n  }\n  date(value, format) {\n    return date(this._locales || this._locale, value, format);\n  }\n  number(value, format) {\n    return number(this._locales || this._locale, value, format);\n  }\n}\nfunction setupI18n(params = {}) {\n  return new I18n(params);\n}\n\nconst i18n = setupI18n();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9jb3JlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4QjtBQUN3Qzs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUJBQWlCO0FBQzVEO0FBQ0E7QUFDQSwyQ0FBMkMsa0JBQWtCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUssR0FBRyxVQUFVLEdBQUcsd0JBQXdCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLEVBQUUsZ0JBQWdCLEVBQUU7QUFDMUQ7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0Q0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QywrQkFBK0IsZ0ZBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUUwQyIsInNvdXJjZXMiOlsiUDpcXEdhbGVvbiBwcm9qZWN0c1xcZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXBcXG1haW5cXG5vZGVfbW9kdWxlc1xcQGxpbmd1aVxcY29yZVxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVucmF3IH0gZnJvbSAndW5yYXcnO1xuaW1wb3J0IHsgY29tcGlsZU1lc3NhZ2UgfSBmcm9tICdAbGluZ3VpL21lc3NhZ2UtdXRpbHMvY29tcGlsZU1lc3NhZ2UnO1xuXG5jb25zdCBpc1N0cmluZyA9IChzKSA9PiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzRnVuY3Rpb24gPSAoZikgPT4gdHlwZW9mIGYgPT09IFwiZnVuY3Rpb25cIjtcblxuY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuY29uc3QgZGVmYXVsdExvY2FsZSA9IFwiZW5cIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcykge1xuICBjb25zdCBvdXQgPSBBcnJheS5pc0FycmF5KGxvY2FsZXMpID8gbG9jYWxlcyA6IFtsb2NhbGVzXTtcbiAgcmV0dXJuIFsuLi5vdXQsIGRlZmF1bHRMb2NhbGVdO1xufVxuZnVuY3Rpb24gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgZm9ybWF0KSB7XG4gIGNvbnN0IF9sb2NhbGVzID0gbm9ybWFsaXplTG9jYWxlcyhsb2NhbGVzKTtcbiAgaWYgKCFmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSBcImRlZmF1bHRcIjtcbiAgfVxuICBsZXQgbztcbiAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvID0ge1xuICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIlxuICAgIH07XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJmdWxsXCI6XG4gICAgICAgIG8ud2Vla2RheSA9IFwibG9uZ1wiO1xuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgby5tb250aCA9IFwibG9uZ1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgICBvLm1vbnRoID0gXCJudW1lcmljXCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvID0gZm9ybWF0O1xuICB9XG4gIGNvbnN0IGZvcm1hdHRlciA9IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwiZGF0ZVwiLCBfbG9jYWxlcywgZm9ybWF0KSxcbiAgICAoKSA9PiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChfbG9jYWxlcywgbylcbiAgKTtcbiAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoaXNTdHJpbmcodmFsdWUpID8gbmV3IERhdGUodmFsdWUpIDogdmFsdWUpO1xufVxuZnVuY3Rpb24gdGltZShsb2NhbGVzLCB2YWx1ZSwgZm9ybWF0KSB7XG4gIGxldCBvO1xuICBpZiAoIWZvcm1hdCkge1xuICAgIGZvcm1hdCA9IFwiZGVmYXVsdFwiO1xuICB9XG4gIGlmICh0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbyA9IHtcbiAgICAgIHNlY29uZDogXCJudW1lcmljXCIsXG4gICAgICBtaW51dGU6IFwibnVtZXJpY1wiLFxuICAgICAgaG91cjogXCJudW1lcmljXCJcbiAgICB9O1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIFwiZnVsbFwiOlxuICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgby50aW1lWm9uZU5hbWUgPSBcInNob3J0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNob3J0XCI6XG4gICAgICAgIGRlbGV0ZSBvLnNlY29uZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbyA9IGZvcm1hdDtcbiAgfVxuICByZXR1cm4gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgbyk7XG59XG5mdW5jdGlvbiBudW1iZXIobG9jYWxlcywgdmFsdWUsIGZvcm1hdCkge1xuICBjb25zdCBfbG9jYWxlcyA9IG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcyk7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwibnVtYmVyXCIsIF9sb2NhbGVzLCBmb3JtYXQpLFxuICAgICgpID0+IG5ldyBJbnRsLk51bWJlckZvcm1hdChfbG9jYWxlcywgZm9ybWF0KVxuICApO1xuICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwbHVyYWwobG9jYWxlcywgb3JkaW5hbCwgdmFsdWUsIHsgb2Zmc2V0ID0gMCwgLi4ucnVsZXMgfSkge1xuICBjb25zdCBfbG9jYWxlcyA9IG5vcm1hbGl6ZUxvY2FsZXMobG9jYWxlcyk7XG4gIGNvbnN0IHBsdXJhbHMgPSBvcmRpbmFsID8gZ2V0TWVtb2l6ZWQoXG4gICAgKCkgPT4gY2FjaGVLZXkoXCJwbHVyYWwtb3JkaW5hbFwiLCBfbG9jYWxlcyksXG4gICAgKCkgPT4gbmV3IEludGwuUGx1cmFsUnVsZXMoX2xvY2FsZXMsIHsgdHlwZTogXCJvcmRpbmFsXCIgfSlcbiAgKSA6IGdldE1lbW9pemVkKFxuICAgICgpID0+IGNhY2hlS2V5KFwicGx1cmFsLWNhcmRpbmFsXCIsIF9sb2NhbGVzKSxcbiAgICAoKSA9PiBuZXcgSW50bC5QbHVyYWxSdWxlcyhfbG9jYWxlcywgeyB0eXBlOiBcImNhcmRpbmFsXCIgfSlcbiAgKTtcbiAgcmV0dXJuIHJ1bGVzW3ZhbHVlXSA/PyBydWxlc1twbHVyYWxzLnNlbGVjdCh2YWx1ZSAtIG9mZnNldCldID8/IHJ1bGVzLm90aGVyO1xufVxuZnVuY3Rpb24gZ2V0TWVtb2l6ZWQoZ2V0S2V5LCBjb25zdHJ1Y3QpIHtcbiAgY29uc3Qga2V5ID0gZ2V0S2V5KCk7XG4gIGxldCBmb3JtYXR0ZXIgPSBjYWNoZS5nZXQoa2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBjb25zdHJ1Y3QoKTtcbiAgICBjYWNoZS5zZXQoa2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBjYWNoZUtleSh0eXBlLCBsb2NhbGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxvY2FsZUtleSA9IGxvY2FsZXMuam9pbihcIi1cIik7XG4gIHJldHVybiBgJHt0eXBlfS0ke2xvY2FsZUtleX0tJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gO1xufVxuXG5jb25zdCBmb3JtYXRzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRhdGU6IGRhdGUsXG4gIGRlZmF1bHRMb2NhbGU6IGRlZmF1bHRMb2NhbGUsXG4gIG51bWJlcjogbnVtYmVyLFxuICBwbHVyYWw6IHBsdXJhbCxcbiAgdGltZTogdGltZVxufTtcblxuY29uc3QgVU5JQ09ERV9SRUdFWCA9IC9cXFxcdVthLWZBLUYwLTldezR9fFxcXFx4W2EtZkEtRjAtOV17Mn0vO1xuY29uc3QgT0NUT1RIT1JQRV9QSCA9IFwiJV9fbGluZ3VpX29jdG90aG9ycGVfXyVcIjtcbmNvbnN0IGdldERlZmF1bHRGb3JtYXRzID0gKGxvY2FsZSwgcGFzc2VkTG9jYWxlcywgZm9ybWF0cyA9IHt9KSA9PiB7XG4gIGNvbnN0IGxvY2FsZXMgPSBwYXNzZWRMb2NhbGVzIHx8IGxvY2FsZTtcbiAgY29uc3Qgc3R5bGUgPSAoZm9ybWF0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIHJldHVybiBmb3JtYXRzW2Zvcm1hdF07XG4gIH07XG4gIGNvbnN0IHJlcGxhY2VPY3RvdGhvcnBlID0gKHZhbHVlLCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbnVtYmVyRm9ybWF0ID0gT2JqZWN0LmtleXMoZm9ybWF0cykubGVuZ3RoID8gc3R5bGUoXCJudW1iZXJcIikgOiB2b2lkIDA7XG4gICAgY29uc3QgdmFsdWVTdHIgPSBudW1iZXIobG9jYWxlcywgdmFsdWUsIG51bWJlckZvcm1hdCk7XG4gICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZShuZXcgUmVnRXhwKE9DVE9USE9SUEVfUEgsIFwiZ1wiKSwgdmFsdWVTdHIpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHBsdXJhbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgZmFsc2UsIHZhbHVlLCBjYXNlcyk7XG4gICAgICByZXR1cm4gcmVwbGFjZU9jdG90aG9ycGUodmFsdWUgLSBvZmZzZXQsIG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgc2VsZWN0b3JkaW5hbDogKHZhbHVlLCBjYXNlcykgPT4ge1xuICAgICAgY29uc3QgeyBvZmZzZXQgPSAwIH0gPSBjYXNlcztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBwbHVyYWwobG9jYWxlcywgdHJ1ZSwgdmFsdWUsIGNhc2VzKTtcbiAgICAgIHJldHVybiByZXBsYWNlT2N0b3Rob3JwZSh2YWx1ZSAtIG9mZnNldCwgbWVzc2FnZSk7XG4gICAgfSxcbiAgICBzZWxlY3Q6IHNlbGVjdEZvcm1hdHRlcixcbiAgICBudW1iZXI6ICh2YWx1ZSwgZm9ybWF0KSA9PiBudW1iZXIoXG4gICAgICBsb2NhbGVzLFxuICAgICAgdmFsdWUsXG4gICAgICBzdHlsZShmb3JtYXQpIHx8IHsgc3R5bGU6IGZvcm1hdCB9XG4gICAgKSxcbiAgICBkYXRlOiAodmFsdWUsIGZvcm1hdCkgPT4gZGF0ZShsb2NhbGVzLCB2YWx1ZSwgc3R5bGUoZm9ybWF0KSB8fCBmb3JtYXQpLFxuICAgIHRpbWU6ICh2YWx1ZSwgZm9ybWF0KSA9PiB0aW1lKGxvY2FsZXMsIHZhbHVlLCBzdHlsZShmb3JtYXQpIHx8IGZvcm1hdClcbiAgfTtcbn07XG5jb25zdCBzZWxlY3RGb3JtYXR0ZXIgPSAodmFsdWUsIHJ1bGVzKSA9PiBydWxlc1t2YWx1ZV0gPz8gcnVsZXMub3RoZXI7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cmFuc2xhdGlvbiwgbG9jYWxlLCBsb2NhbGVzKSB7XG4gIHJldHVybiAodmFsdWVzID0ge30sIGZvcm1hdHMpID0+IHtcbiAgICBjb25zdCBmb3JtYXR0ZXJzID0gZ2V0RGVmYXVsdEZvcm1hdHMobG9jYWxlLCBsb2NhbGVzLCBmb3JtYXRzKTtcbiAgICBjb25zdCBmb3JtYXRNZXNzYWdlID0gKHRva2VucywgcmVwbGFjZU9jdG90aG9ycGUgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VucykpXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICByZXR1cm4gdG9rZW5zLnJlZHVjZSgobWVzc2FnZSwgdG9rZW4pID0+IHtcbiAgICAgICAgaWYgKHRva2VuID09PSBcIiNcIiAmJiByZXBsYWNlT2N0b3Rob3JwZSkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgT0NUT1RIT1JQRV9QSDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcodG9rZW4pKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbmFtZSwgdHlwZSwgZm9ybWF0XSA9IHRva2VuO1xuICAgICAgICBsZXQgaW50ZXJwb2xhdGVkRm9ybWF0ID0ge307XG4gICAgICAgIGlmICh0eXBlID09PSBcInBsdXJhbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0b3JkaW5hbFwiIHx8IHR5cGUgPT09IFwic2VsZWN0XCIpIHtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhmb3JtYXQpLmZvckVhY2goXG4gICAgICAgICAgICAoW2tleSwgdmFsdWUyXSkgPT4ge1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRGb3JtYXRba2V5XSA9IGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICAgIHR5cGUgPT09IFwicGx1cmFsXCIgfHwgdHlwZSA9PT0gXCJzZWxlY3RvcmRpbmFsXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlZEZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0dGVyc1t0eXBlXTtcbiAgICAgICAgICB2YWx1ZSA9IGZvcm1hdHRlcih2YWx1ZXNbbmFtZV0sIGludGVycG9sYXRlZEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZSArIHZhbHVlO1xuICAgICAgfSwgXCJcIik7XG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBmb3JtYXRNZXNzYWdlKHRyYW5zbGF0aW9uKTtcbiAgICBpZiAoaXNTdHJpbmcocmVzdWx0KSAmJiBVTklDT0RFX1JFR0VYLnRlc3QocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHVucmF3KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZyhyZXN1bHQpKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0ID8gU3RyaW5nKHJlc3VsdCkgOiBcIlwiO1xuICB9O1xufVxuXG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwiX2V2ZW50c1wiLCB7fSk7XG4gIH1cbiAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuX2V2ZW50cylbZXZlbnRdID8/IChfYVtldmVudF0gPSBbXSk7XG4gICAgdGhpcy5fZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluZGV4ID0gbWF5YmVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKH5pbmRleClcbiAgICAgIG1heWJlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGNvbnN0IG1heWJlTGlzdGVuZXJzID0gdGhpcy5fZ2V0TGlzdGVuZXJzKGV2ZW50KTtcbiAgICBpZiAoIW1heWJlTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIG1heWJlTGlzdGVuZXJzLm1hcCgobGlzdGVuZXIpID0+IGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgfVxuICBfZ2V0TGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgY29uc3QgbWF5YmVMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZlbnRdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG1heWJlTGlzdGVuZXJzKSA/IG1heWJlTGlzdGVuZXJzIDogZmFsc2U7XG4gIH1cbn1cblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgSTE4biBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVcIiwgXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9sb2NhbGVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbG9jYWxlRGF0YVwiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9tZXNzYWdlc1wiLCB7fSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9taXNzaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbWVzc2FnZUNvbXBpbGVyXCIpO1xuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QHNlZSBJMThuLl99XG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRcIiwgdGhpcy5fLmJpbmQodGhpcykpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRoaXMuc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubWlzc2luZyAhPSBudWxsKVxuICAgICAgdGhpcy5fbWlzc2luZyA9IHBhcmFtcy5taXNzaW5nO1xuICAgIGlmIChwYXJhbXMubWVzc2FnZXMgIT0gbnVsbClcbiAgICAgIHRoaXMubG9hZChwYXJhbXMubWVzc2FnZXMpO1xuICAgIGlmIChwYXJhbXMubG9jYWxlRGF0YSAhPSBudWxsKVxuICAgICAgdGhpcy5sb2FkTG9jYWxlRGF0YShwYXJhbXMubG9jYWxlRGF0YSk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMubG9jYWxlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtcy5sb2NhbGVzKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKHBhcmFtcy5sb2NhbGUgPz8gZGVmYXVsdExvY2FsZSwgcGFyYW1zLmxvY2FsZXMpO1xuICAgIH1cbiAgfVxuICBnZXQgbG9jYWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gIH1cbiAgZ2V0IGxvY2FsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZXM7XG4gIH1cbiAgZ2V0IG1lc3NhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB0aGlzIGhhcyBubyBlZmZlY3QuIFBsZWFzZSByZW1vdmUgdGhpcyBmcm9tIHRoZSBjb2RlLiBEZXByZWNhdGVkIGluIHY0XG4gICAqL1xuICBnZXQgbG9jYWxlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlRGF0YVt0aGlzLl9sb2NhbGVdID8/IHt9O1xuICB9XG4gIF9sb2FkTG9jYWxlRGF0YShsb2NhbGUsIGxvY2FsZURhdGEpIHtcbiAgICBjb25zdCBtYXliZUxvY2FsZURhdGEgPSB0aGlzLl9sb2NhbGVEYXRhW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZUxvY2FsZURhdGEpIHtcbiAgICAgIHRoaXMuX2xvY2FsZURhdGFbbG9jYWxlXSA9IGxvY2FsZURhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVMb2NhbGVEYXRhLCBsb2NhbGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBNZXNzYWdlQ29tcGlsZXJgIHRvIGVuYWJsZSB0aGUgdXNlIG9mIHVuY29tcGlsZWQgY2F0YWxvZ3MgYXQgcnVudGltZS5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiBidWlsZHMsIHRoZSBgTWVzc2FnZUNvbXBpbGVyYCBpcyB0eXBpY2FsbHkgZXhjbHVkZWQgdG8gcmVkdWNlIGJ1bmRsZSBzaXplLlxuICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlIGNhdGFsb2dzIHNob3VsZCBiZSBwcmVjb21waWxlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MuIEhvd2V2ZXIsXG4gICAqIGlmIHlvdSBuZWVkIHRvIGNvbXBpbGUgY2F0YWxvZ3MgYXQgcnVudGltZSwgeW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gc2V0IGEgbWVzc2FnZSBjb21waWxlci5cbiAgICpcbiAgICogRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogYGBgdHNcbiAgICogaW1wb3J0IHsgY29tcGlsZU1lc3NhZ2UgfSBmcm9tIFwiQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2NvbXBpbGVNZXNzYWdlXCI7XG4gICAqXG4gICAqIGkxOG4uc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlTWVzc2FnZSk7XG4gICAqIGBgYFxuICAgKi9cbiAgc2V0TWVzc2FnZXNDb21waWxlcihjb21waWxlcikge1xuICAgIHRoaXMuX21lc3NhZ2VDb21waWxlciA9IGNvbXBpbGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBQbHVyYWxzIGF1dG9tYXRpY2FsbHkgdXNlZCBmcm9tIEludGwuUGx1cmFsUnVsZXMgeW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gRGVwcmVjYXRlZCBpbiB2NFxuICAgKi9cbiAgbG9hZExvY2FsZURhdGEobG9jYWxlT3JBbGxEYXRhLCBsb2NhbGVEYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPckFsbERhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuX2xvYWRMb2NhbGVEYXRhKGxvY2FsZU9yQWxsRGF0YSwgbG9jYWxlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGxvY2FsZU9yQWxsRGF0YSkuZm9yRWFjaChcbiAgICAgICAgKGxvY2FsZSkgPT4gdGhpcy5fbG9hZExvY2FsZURhdGEobG9jYWxlLCBsb2NhbGVPckFsbERhdGFbbG9jYWxlXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICBfbG9hZChsb2NhbGUsIG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgbWF5YmVNZXNzYWdlcyA9IHRoaXMuX21lc3NhZ2VzW2xvY2FsZV07XG4gICAgaWYgKCFtYXliZU1lc3NhZ2VzKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlc1tsb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24obWF5YmVNZXNzYWdlcywgbWVzc2FnZXMpO1xuICAgIH1cbiAgfVxuICBsb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVPck1lc3NhZ2VzID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG1lc3NhZ2VzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLl9sb2FkKGxvY2FsZU9yTWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmVudHJpZXMobG9jYWxlT3JNZXNzYWdlcykuZm9yRWFjaChcbiAgICAgICAgKFtsb2NhbGUsIG1lc3NhZ2VzMl0pID0+IHRoaXMuX2xvYWQobG9jYWxlLCBtZXNzYWdlczIpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtAbGluayBMb2FkQW5kQWN0aXZhdGVPcHRpb25zfVxuICAgKi9cbiAgbG9hZEFuZEFjdGl2YXRlKHsgbG9jYWxlLCBsb2NhbGVzLCBtZXNzYWdlcyB9KSB7XG4gICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuX2xvY2FsZXMgPSBsb2NhbGVzIHx8IHZvaWQgMDtcbiAgICB0aGlzLl9tZXNzYWdlc1t0aGlzLl9sb2NhbGVdID0gbWVzc2FnZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIGFjdGl2YXRlKGxvY2FsZSwgbG9jYWxlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghdGhpcy5fbWVzc2FnZXNbbG9jYWxlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE1lc3NhZ2VzIGZvciBsb2NhbGUgXCIke2xvY2FsZX1cIiBub3QgbG9hZGVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5fbG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIF8oaWQsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGlmICghdGhpcy5sb2NhbGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJMaW5ndWk6IEF0dGVtcHRlZCB0byBjYWxsIGEgdHJhbnNsYXRpb24gZnVuY3Rpb24gd2l0aG91dCBzZXR0aW5nIGEgbG9jYWxlLlxcbk1ha2Ugc3VyZSB0byBjYWxsIGBpMThuLmFjdGl2YXRlKGxvY2FsZSlgIGJlZm9yZSB1c2luZyBMaW5ndWkgZnVuY3Rpb25zLlxcblRoaXMgaXNzdWUgbWF5IGFsc28gb2NjdXIgZHVlIHRvIGEgcmFjZSBjb25kaXRpb24gaW4geW91ciBpbml0aWFsaXphdGlvbiBsb2dpYy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBvcHRpb25zPy5tZXNzYWdlO1xuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhpZCkpIHtcbiAgICAgIHZhbHVlcyA9IGlkLnZhbHVlcyB8fCB2YWx1ZXM7XG4gICAgICBtZXNzYWdlID0gaWQubWVzc2FnZTtcbiAgICAgIGlkID0gaWQuaWQ7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VGb3JJZCA9IHRoaXMubWVzc2FnZXNbaWRdO1xuICAgIGNvbnN0IG1lc3NhZ2VNaXNzaW5nID0gbWVzc2FnZUZvcklkID09PSB2b2lkIDA7XG4gICAgY29uc3QgbWlzc2luZyA9IHRoaXMuX21pc3Npbmc7XG4gICAgaWYgKG1pc3NpbmcgJiYgbWVzc2FnZU1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG1pc3NpbmcpID8gbWlzc2luZyh0aGlzLl9sb2NhbGUsIGlkKSA6IG1pc3Npbmc7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlTWlzc2luZykge1xuICAgICAgdGhpcy5lbWl0KFwibWlzc2luZ1wiLCB7IGlkLCBsb2NhbGU6IHRoaXMuX2xvY2FsZSB9KTtcbiAgICB9XG4gICAgbGV0IHRyYW5zbGF0aW9uID0gbWVzc2FnZUZvcklkIHx8IG1lc3NhZ2UgfHwgaWQ7XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSkge1xuICAgICAgaWYgKHRoaXMuX21lc3NhZ2VDb21waWxlcikge1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHRoaXMuX21lc3NhZ2VDb21waWxlcih0cmFuc2xhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuY29tcGlsZWQgbWVzc2FnZSBkZXRlY3RlZCEgTWVzc2FnZTpcblxuPiAke3RyYW5zbGF0aW9ufVxuXG5UaGF0IG1lYW5zIHlvdSB1c2UgcmF3IGNhdGFsb2cgb3IgeW91ciBjYXRhbG9nIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zbGF0aW9uIGZvciB0aGUgbWVzc2FnZSBhbmQgZmFsbGJhY2sgd2FzIHVzZWQuXG5JQ1UgZmVhdHVyZXMgc3VjaCBhcyBpbnRlcnBvbGF0aW9uIGFuZCBwbHVyYWxzIHdpbGwgbm90IHdvcmsgcHJvcGVybHkgZm9yIHRoYXQgbWVzc2FnZS4gXG5cblBsZWFzZSBjb21waWxlIHlvdXIgY2F0YWxvZyBmaXJzdC4gXG5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSAmJiBVTklDT0RFX1JFR0VYLnRlc3QodHJhbnNsYXRpb24pKVxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYFwiJHt0cmFuc2xhdGlvbn1cImApO1xuICAgIGlmIChpc1N0cmluZyh0cmFuc2xhdGlvbikpXG4gICAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gICAgcmV0dXJuIGludGVycG9sYXRlKFxuICAgICAgdHJhbnNsYXRpb24sXG4gICAgICB0aGlzLl9sb2NhbGUsXG4gICAgICB0aGlzLl9sb2NhbGVzXG4gICAgKSh2YWx1ZXMsIG9wdGlvbnM/LmZvcm1hdHMpO1xuICB9XG4gIGRhdGUodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBkYXRlKHRoaXMuX2xvY2FsZXMgfHwgdGhpcy5fbG9jYWxlLCB2YWx1ZSwgZm9ybWF0KTtcbiAgfVxuICBudW1iZXIodmFsdWUsIGZvcm1hdCkge1xuICAgIHJldHVybiBudW1iZXIodGhpcy5fbG9jYWxlcyB8fCB0aGlzLl9sb2NhbGUsIHZhbHVlLCBmb3JtYXQpO1xuICB9XG59XG5mdW5jdGlvbiBzZXR1cEkxOG4ocGFyYW1zID0ge30pIHtcbiAgcmV0dXJuIG5ldyBJMThuKHBhcmFtcyk7XG59XG5cbmNvbnN0IGkxOG4gPSBzZXR1cEkxOG4oKTtcblxuZXhwb3J0IHsgSTE4biwgZm9ybWF0cywgaTE4biwgc2V0dXBJMThuIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lingui/message-utils/dist/compileMessage.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compileMessage: () => (/* binding */ compileMessage)\n/* harmony export */ });\n/* harmony import */ var _messageformat_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @messageformat/parser */ \"(ssr)/./node_modules/@messageformat/parser/lib/parser.js\");\n\n\n/**\n * Parent class for errors.\n *\n * @remarks\n * Errors with `type: \"warning\"` do not necessarily indicate that the parser\n * encountered an error. In addition to a human-friendly `message`, may also\n * includes the `token` at which the error was encountered.\n *\n * @public\n */\nclass DateFormatError extends Error {\n    /** @internal */\n    constructor(msg, token, type) {\n        super(msg);\n        this.token = token;\n        this.type = type || 'error';\n    }\n}\nconst alpha = (width) => width < 4 ? 'short' : width === 4 ? 'long' : 'narrow';\nconst numeric = (width) => (width % 2 === 0 ? '2-digit' : 'numeric');\nfunction yearOptions(token, onError) {\n    switch (token.char) {\n        case 'y':\n            return { year: numeric(token.width) };\n        case 'r':\n            return { calendar: 'gregory', year: 'numeric' };\n        case 'u':\n        case 'U':\n        case 'Y':\n        default:\n            onError(`${token.desc} is not supported; falling back to year:numeric`, DateFormatError.WARNING);\n            return { year: 'numeric' };\n    }\n}\nfunction monthStyle(token, onError) {\n    switch (token.width) {\n        case 1:\n            return 'numeric';\n        case 2:\n            return '2-digit';\n        case 3:\n            return 'short';\n        case 4:\n            return 'long';\n        case 5:\n            return 'narrow';\n        default:\n            onError(`${token.desc} is not supported with width ${token.width}`);\n            return undefined;\n    }\n}\nfunction dayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if (char === 'd') {\n        return numeric(width);\n    }\n    else {\n        onError(`${desc} is not supported`);\n        return undefined;\n    }\n}\nfunction weekdayStyle(token, onError) {\n    const { char, desc, width } = token;\n    if ((char === 'c' || char === 'e') && width < 3) {\n        // ignoring stand-alone-ness\n        const msg = `Numeric value is not supported for ${desc}; falling back to weekday:short`;\n        onError(msg, DateFormatError.WARNING);\n    }\n    // merging narrow styles\n    return alpha(width);\n}\nfunction hourOptions(token) {\n    const hour = numeric(token.width);\n    let hourCycle;\n    switch (token.char) {\n        case 'h':\n            hourCycle = 'h12';\n            break;\n        case 'H':\n            hourCycle = 'h23';\n            break;\n        case 'k':\n            hourCycle = 'h24';\n            break;\n        case 'K':\n            hourCycle = 'h11';\n            break;\n    }\n    return hourCycle ? { hour, hourCycle } : { hour };\n}\nfunction timeZoneNameStyle(token, onError) {\n    // so much fallback behaviour here\n    const { char, desc, width } = token;\n    switch (char) {\n        case 'v':\n        case 'z':\n            return width === 4 ? 'long' : 'short';\n        case 'V':\n            if (width === 4)\n                return 'long';\n            onError(`${desc} is not supported with width ${width}`);\n            return undefined;\n        case 'X':\n            onError(`${desc} is not supported`);\n            return undefined;\n    }\n    return 'short';\n}\nfunction compileOptions(token, onError) {\n    switch (token.field) {\n        case 'era':\n            return { era: alpha(token.width) };\n        case 'year':\n            return yearOptions(token, onError);\n        case 'month':\n            return { month: monthStyle(token, onError) };\n        case 'day':\n            return { day: dayStyle(token, onError) };\n        case 'weekday':\n            return { weekday: weekdayStyle(token, onError) };\n        case 'period':\n            return undefined;\n        case 'hour':\n            return hourOptions(token);\n        case 'min':\n            return { minute: numeric(token.width) };\n        case 'sec':\n            return { second: numeric(token.width) };\n        case 'tz':\n            return { timeZoneName: timeZoneNameStyle(token, onError) };\n        case 'quarter':\n        case 'week':\n        case 'sec-frac':\n        case 'ms':\n            onError(`${token.desc} is not supported`);\n    }\n    return undefined;\n}\nfunction getDateFormatOptions(tokens, timeZone, onError = error => {\n    throw error;\n}) {\n    const options = {\n        timeZone\n    };\n    const fields = [];\n    for (const token of tokens) {\n        const { error, field, str } = token;\n        if (error) {\n            const dte = new DateFormatError(error.message, token);\n            dte.stack = error.stack;\n            onError(dte);\n        }\n        if (str) {\n            const msg = `Ignoring string part: ${str}`;\n            onError(new DateFormatError(msg, token, DateFormatError.WARNING));\n        }\n        if (field) {\n            if (fields.indexOf(field) === -1)\n                fields.push(field);\n            else\n                onError(new DateFormatError(`Duplicate ${field} token`, token));\n        }\n        const opt = compileOptions(token, (msg, isWarning) => onError(new DateFormatError(msg, token, isWarning)));\n        if (opt)\n            Object.assign(options, opt);\n    }\n    return options;\n}\n\nconst fields = {\n    G: { field: 'era', desc: 'Era' },\n    y: { field: 'year', desc: 'Year' },\n    Y: { field: 'year', desc: 'Year of \"Week of Year\"' },\n    u: { field: 'year', desc: 'Extended year' },\n    U: { field: 'year', desc: 'Cyclic year name' },\n    r: { field: 'year', desc: 'Related Gregorian year' },\n    Q: { field: 'quarter', desc: 'Quarter' },\n    q: { field: 'quarter', desc: 'Stand-alone quarter' },\n    M: { field: 'month', desc: 'Month in year' },\n    L: { field: 'month', desc: 'Stand-alone month in year' },\n    w: { field: 'week', desc: 'Week of year' },\n    W: { field: 'week', desc: 'Week of month' },\n    d: { field: 'day', desc: 'Day in month' },\n    D: { field: 'day', desc: 'Day of year' },\n    F: { field: 'day', desc: 'Day of week in month' },\n    g: { field: 'day', desc: 'Modified julian day' },\n    E: { field: 'weekday', desc: 'Day of week' },\n    e: { field: 'weekday', desc: 'Local day of week' },\n    c: { field: 'weekday', desc: 'Stand-alone local day of week' },\n    a: { field: 'period', desc: 'AM/PM marker' },\n    b: { field: 'period', desc: 'AM/PM/noon/midnight marker' },\n    B: { field: 'period', desc: 'Flexible day period' },\n    h: { field: 'hour', desc: 'Hour in AM/PM (1~12)' },\n    H: { field: 'hour', desc: 'Hour in day (0~23)' },\n    k: { field: 'hour', desc: 'Hour in day (1~24)' },\n    K: { field: 'hour', desc: 'Hour in AM/PM (0~11)' },\n    j: { field: 'hour', desc: 'Hour in preferred cycle' },\n    J: { field: 'hour', desc: 'Hour in preferred cycle without marker' },\n    C: { field: 'hour', desc: 'Hour in preferred cycle with flexible marker' },\n    m: { field: 'min', desc: 'Minute in hour' },\n    s: { field: 'sec', desc: 'Second in minute' },\n    S: { field: 'sec-frac', desc: 'Fractional second' },\n    A: { field: 'ms', desc: 'Milliseconds in day' },\n    z: { field: 'tz', desc: 'Time Zone: specific non-location' },\n    Z: { field: 'tz', desc: 'Time Zone' },\n    O: { field: 'tz', desc: 'Time Zone: localized' },\n    v: { field: 'tz', desc: 'Time Zone: generic non-location' },\n    V: { field: 'tz', desc: 'Time Zone: ID' },\n    X: { field: 'tz', desc: 'Time Zone: ISO8601 with Z' },\n    x: { field: 'tz', desc: 'Time Zone: ISO8601' }\n};\nconst isLetter = (char) => (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');\nfunction readFieldToken(src, pos) {\n    const char = src[pos];\n    let width = 1;\n    while (src[++pos] === char)\n        ++width;\n    const field = fields[char];\n    if (!field) {\n        const msg = `The letter ${char} is not a valid field identifier`;\n        return { char, error: new Error(msg), width };\n    }\n    return { char, field: field.field, desc: field.desc, width };\n}\nfunction readQuotedToken(src, pos) {\n    let str = src[++pos];\n    let width = 2;\n    if (str === \"'\")\n        return { char: \"'\", str, width };\n    while (true) {\n        const next = src[++pos];\n        ++width;\n        if (next === undefined) {\n            const msg = `Unterminated quoted literal in pattern: ${str || src}`;\n            return { char: \"'\", error: new Error(msg), str, width };\n        }\n        else if (next === \"'\") {\n            if (src[++pos] !== \"'\")\n                return { char: \"'\", str, width };\n            else\n                ++width;\n        }\n        str += next;\n    }\n}\nfunction readToken(src, pos) {\n    const char = src[pos];\n    if (!char)\n        return null;\n    if (isLetter(char))\n        return readFieldToken(src, pos);\n    if (char === \"'\")\n        return readQuotedToken(src, pos);\n    let str = char;\n    let width = 1;\n    while (true) {\n        const next = src[++pos];\n        if (!next || isLetter(next) || next === \"'\")\n            return { char, str, width };\n        str += next;\n        width += 1;\n    }\n}\n/**\n * Parse an {@link http://userguide.icu-project.org/formatparse/datetime | ICU\n * DateFormat skeleton} string into a {@link DateToken} array.\n *\n * @remarks\n * Errors will not be thrown, but if encountered are included as the relevant\n * token's `error` value.\n *\n * @public\n * @param src - The skeleton string\n *\n * @example\n * ```js\n * import { parseDateTokens } from '@messageformat/date-skeleton'\n *\n * parseDateTokens('GrMMMdd', console.error)\n * // [\n * //   { char: 'G', field: 'era', desc: 'Era', width: 1 },\n * //   { char: 'r', field: 'year', desc: 'Related Gregorian year', width: 1 },\n * //   { char: 'M', field: 'month', desc: 'Month in year', width: 3 },\n * //   { char: 'd', field: 'day', desc: 'Day in month', width: 2 }\n * // ]\n * ```\n */\nfunction parseDateTokens(src) {\n    const tokens = [];\n    let pos = 0;\n    while (true) {\n        const token = readToken(src, pos);\n        if (!token)\n            return tokens;\n        tokens.push(token);\n        pos += token.width;\n    }\n}\n\nfunction processTokens(tokens, mapText) {\n  if (!tokens.filter((token) => token.type !== \"content\").length) {\n    return tokens.map((token) => mapText(token.value));\n  }\n  return tokens.map((token) => {\n    if (token.type === \"content\") {\n      return mapText(token.value);\n    } else if (token.type === \"octothorpe\") {\n      return \"#\";\n    } else if (token.type === \"argument\") {\n      return [token.arg];\n    } else if (token.type === \"function\") {\n      const _param = token?.param?.[0];\n      if (token.key === \"date\" && _param) {\n        const opts = compileDateExpression(_param.value.trim(), (e) => {\n          throw new Error(`Unable to compile date expression: ${e.message}`);\n        });\n        return [token.arg, token.key, opts];\n      }\n      if (_param) {\n        return [token.arg, token.key, _param.value.trim()];\n      } else {\n        return [token.arg, token.key];\n      }\n    }\n    const offset = token.pluralOffset;\n    const formatProps = {};\n    token.cases.forEach(({ key, tokens: tokens2 }) => {\n      const prop = key[0] === \"=\" ? key.slice(1) : key;\n      formatProps[prop] = processTokens(tokens2, mapText);\n    });\n    return [\n      token.arg,\n      token.type,\n      {\n        offset,\n        ...formatProps\n      }\n    ];\n  });\n}\nfunction compileDateExpression(format, onError) {\n  if (/^::/.test(format)) {\n    const tokens = parseDateTokens(format.substring(2));\n    return getDateFormatOptions(tokens, void 0, onError);\n  }\n  return format;\n}\nfunction compileMessage(message, mapText = (v) => v) {\n  try {\n    return processTokens((0,_messageformat_parser__WEBPACK_IMPORTED_MODULE_0__.parse)(message), mapText);\n  } catch (e) {\n    console.error(`${e.message} \n\nMessage: ${message}`);\n    return [message];\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9tZXNzYWdlLXV0aWxzL2Rpc3QvY29tcGlsZU1lc3NhZ2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVksa0JBQWtCO0FBQ3JELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWSw4QkFBOEIsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0EsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTSw4QkFBOEIsTUFBTTtBQUNqRTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywyQkFBMkI7QUFDcEMsU0FBUyw2QkFBNkI7QUFDdEMsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxzQ0FBc0M7QUFDL0MsU0FBUyx5Q0FBeUM7QUFDbEQsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyxtQ0FBbUM7QUFDNUMsU0FBUywrQ0FBK0M7QUFDeEQsU0FBUyx1Q0FBdUM7QUFDaEQsU0FBUyxtREFBbUQ7QUFDNUQsU0FBUyxxQ0FBcUM7QUFDOUMsU0FBUyxzQ0FBc0M7QUFDL0MsU0FBUyxvQ0FBb0M7QUFDN0MsU0FBUyxtQ0FBbUM7QUFDNUMsU0FBUyw0Q0FBNEM7QUFDckQsU0FBUywyQ0FBMkM7QUFDcEQsU0FBUyx1Q0FBdUM7QUFDaEQsU0FBUyw2Q0FBNkM7QUFDdEQsU0FBUyx5REFBeUQ7QUFDbEUsU0FBUyx1Q0FBdUM7QUFDaEQsU0FBUyxxREFBcUQ7QUFDOUQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUyw2Q0FBNkM7QUFDdEQsU0FBUywyQ0FBMkM7QUFDcEQsU0FBUywyQ0FBMkM7QUFDcEQsU0FBUyw2Q0FBNkM7QUFDdEQsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUywrREFBK0Q7QUFDeEUsU0FBUyxxRUFBcUU7QUFDOUUsU0FBUyxzQ0FBc0M7QUFDL0MsU0FBUyx3Q0FBd0M7QUFDakQsU0FBUyw4Q0FBOEM7QUFDdkQsU0FBUywwQ0FBMEM7QUFDbkQsU0FBUyx1REFBdUQ7QUFDaEUsU0FBUyxnQ0FBZ0M7QUFDekMsU0FBUywyQ0FBMkM7QUFDcEQsU0FBUyxzREFBc0Q7QUFDL0QsU0FBUyxvQ0FBb0M7QUFDN0MsU0FBUyxnREFBZ0Q7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHdCQUF3QixlQUFlLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0RBQWdEO0FBQzFELFVBQVUsb0VBQW9FO0FBQzlFLFVBQVUsNERBQTREO0FBQ3RFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQUs7QUFDOUIsSUFBSTtBQUNKLHFCQUFxQjs7QUFFckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFMEIiLCJzb3VyY2VzIjpbIlA6XFxHYWxlb24gcHJvamVjdHNcXGdhbGVvbi1jb21tdW5pdHktaG9zcGl0YWwtbWFwXFxtYWluXFxub2RlX21vZHVsZXNcXEBsaW5ndWlcXG1lc3NhZ2UtdXRpbHNcXGRpc3RcXGNvbXBpbGVNZXNzYWdlLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSB9IGZyb20gJ0BtZXNzYWdlZm9ybWF0L3BhcnNlcic7XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBlcnJvcnMuXG4gKlxuICogQHJlbWFya3NcbiAqIEVycm9ycyB3aXRoIGB0eXBlOiBcIndhcm5pbmdcImAgZG8gbm90IG5lY2Vzc2FyaWx5IGluZGljYXRlIHRoYXQgdGhlIHBhcnNlclxuICogZW5jb3VudGVyZWQgYW4gZXJyb3IuIEluIGFkZGl0aW9uIHRvIGEgaHVtYW4tZnJpZW5kbHkgYG1lc3NhZ2VgLCBtYXkgYWxzb1xuICogaW5jbHVkZXMgdGhlIGB0b2tlbmAgYXQgd2hpY2ggdGhlIGVycm9yIHdhcyBlbmNvdW50ZXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIERhdGVGb3JtYXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3RydWN0b3IobXNnLCB0b2tlbiwgdHlwZSkge1xuICAgICAgICBzdXBlcihtc2cpO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgJ2Vycm9yJztcbiAgICB9XG59XG5jb25zdCBhbHBoYSA9ICh3aWR0aCkgPT4gd2lkdGggPCA0ID8gJ3Nob3J0JyA6IHdpZHRoID09PSA0ID8gJ2xvbmcnIDogJ25hcnJvdyc7XG5jb25zdCBudW1lcmljID0gKHdpZHRoKSA9PiAod2lkdGggJSAyID09PSAwID8gJzItZGlnaXQnIDogJ251bWVyaWMnKTtcbmZ1bmN0aW9uIHllYXJPcHRpb25zKHRva2VuLCBvbkVycm9yKSB7XG4gICAgc3dpdGNoICh0b2tlbi5jaGFyKSB7XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgcmV0dXJuIHsgeWVhcjogbnVtZXJpYyh0b2tlbi53aWR0aCkgfTtcbiAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXR1cm4geyBjYWxlbmRhcjogJ2dyZWdvcnknLCB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICAgICAgY2FzZSAndSc6XG4gICAgICAgIGNhc2UgJ1UnOlxuICAgICAgICBjYXNlICdZJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG9uRXJyb3IoYCR7dG9rZW4uZGVzY30gaXMgbm90IHN1cHBvcnRlZDsgZmFsbGluZyBiYWNrIHRvIHllYXI6bnVtZXJpY2AsIERhdGVGb3JtYXRFcnJvci5XQVJOSU5HKTtcbiAgICAgICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJyB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1vbnRoU3R5bGUodG9rZW4sIG9uRXJyb3IpIHtcbiAgICBzd2l0Y2ggKHRva2VuLndpZHRoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAnbnVtZXJpYyc7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiAnMi1kaWdpdCc7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiAnc2hvcnQnO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gJ2xvbmcnO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gJ25hcnJvdyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKGAke3Rva2VuLmRlc2N9IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCB3aWR0aCAke3Rva2VuLndpZHRofWApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXlTdHlsZSh0b2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgY2hhciwgZGVzYywgd2lkdGggfSA9IHRva2VuO1xuICAgIGlmIChjaGFyID09PSAnZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMod2lkdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb25FcnJvcihgJHtkZXNjfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gd2Vla2RheVN0eWxlKHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBjaGFyLCBkZXNjLCB3aWR0aCB9ID0gdG9rZW47XG4gICAgaWYgKChjaGFyID09PSAnYycgfHwgY2hhciA9PT0gJ2UnKSAmJiB3aWR0aCA8IDMpIHtcbiAgICAgICAgLy8gaWdub3Jpbmcgc3RhbmQtYWxvbmUtbmVzc1xuICAgICAgICBjb25zdCBtc2cgPSBgTnVtZXJpYyB2YWx1ZSBpcyBub3Qgc3VwcG9ydGVkIGZvciAke2Rlc2N9OyBmYWxsaW5nIGJhY2sgdG8gd2Vla2RheTpzaG9ydGA7XG4gICAgICAgIG9uRXJyb3IobXNnLCBEYXRlRm9ybWF0RXJyb3IuV0FSTklORyk7XG4gICAgfVxuICAgIC8vIG1lcmdpbmcgbmFycm93IHN0eWxlc1xuICAgIHJldHVybiBhbHBoYSh3aWR0aCk7XG59XG5mdW5jdGlvbiBob3VyT3B0aW9ucyh0b2tlbikge1xuICAgIGNvbnN0IGhvdXIgPSBudW1lcmljKHRva2VuLndpZHRoKTtcbiAgICBsZXQgaG91ckN5Y2xlO1xuICAgIHN3aXRjaCAodG9rZW4uY2hhcikge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGhvdXJDeWNsZSA9ICdoMTInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgaG91ckN5Y2xlID0gJ2gyMyc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICBob3VyQ3ljbGUgPSAnaDI0JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLJzpcbiAgICAgICAgICAgIGhvdXJDeWNsZSA9ICdoMTEnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBob3VyQ3ljbGUgPyB7IGhvdXIsIGhvdXJDeWNsZSB9IDogeyBob3VyIH07XG59XG5mdW5jdGlvbiB0aW1lWm9uZU5hbWVTdHlsZSh0b2tlbiwgb25FcnJvcikge1xuICAgIC8vIHNvIG11Y2ggZmFsbGJhY2sgYmVoYXZpb3VyIGhlcmVcbiAgICBjb25zdCB7IGNoYXIsIGRlc2MsIHdpZHRoIH0gPSB0b2tlbjtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoID09PSA0ID8gJ2xvbmcnIDogJ3Nob3J0JztcbiAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IDQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsb25nJztcbiAgICAgICAgICAgIG9uRXJyb3IoYCR7ZGVzY30gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHdpZHRoICR7d2lkdGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIG9uRXJyb3IoYCR7ZGVzY30gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuICdzaG9ydCc7XG59XG5mdW5jdGlvbiBjb21waWxlT3B0aW9ucyh0b2tlbiwgb25FcnJvcikge1xuICAgIHN3aXRjaCAodG9rZW4uZmllbGQpIHtcbiAgICAgICAgY2FzZSAnZXJhJzpcbiAgICAgICAgICAgIHJldHVybiB7IGVyYTogYWxwaGEodG9rZW4ud2lkdGgpIH07XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgcmV0dXJuIHllYXJPcHRpb25zKHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgcmV0dXJuIHsgbW9udGg6IG1vbnRoU3R5bGUodG9rZW4sIG9uRXJyb3IpIH07XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICByZXR1cm4geyBkYXk6IGRheVN0eWxlKHRva2VuLCBvbkVycm9yKSB9O1xuICAgICAgICBjYXNlICd3ZWVrZGF5JzpcbiAgICAgICAgICAgIHJldHVybiB7IHdlZWtkYXk6IHdlZWtkYXlTdHlsZSh0b2tlbiwgb25FcnJvcikgfTtcbiAgICAgICAgY2FzZSAncGVyaW9kJzpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgcmV0dXJuIGhvdXJPcHRpb25zKHRva2VuKTtcbiAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgIHJldHVybiB7IG1pbnV0ZTogbnVtZXJpYyh0b2tlbi53aWR0aCkgfTtcbiAgICAgICAgY2FzZSAnc2VjJzpcbiAgICAgICAgICAgIHJldHVybiB7IHNlY29uZDogbnVtZXJpYyh0b2tlbi53aWR0aCkgfTtcbiAgICAgICAgY2FzZSAndHonOlxuICAgICAgICAgICAgcmV0dXJuIHsgdGltZVpvbmVOYW1lOiB0aW1lWm9uZU5hbWVTdHlsZSh0b2tlbiwgb25FcnJvcikgfTtcbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdzZWMtZnJhYyc6XG4gICAgICAgIGNhc2UgJ21zJzpcbiAgICAgICAgICAgIG9uRXJyb3IoYCR7dG9rZW4uZGVzY30gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RGF0ZUZvcm1hdE9wdGlvbnModG9rZW5zLCB0aW1lWm9uZSwgb25FcnJvciA9IGVycm9yID0+IHtcbiAgICB0aHJvdyBlcnJvcjtcbn0pIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICB0aW1lWm9uZVxuICAgIH07XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvciwgZmllbGQsIHN0ciB9ID0gdG9rZW47XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZHRlID0gbmV3IERhdGVGb3JtYXRFcnJvcihlcnJvci5tZXNzYWdlLCB0b2tlbik7XG4gICAgICAgICAgICBkdGUuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgICAgICAgIG9uRXJyb3IoZHRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgSWdub3Jpbmcgc3RyaW5nIHBhcnQ6ICR7c3RyfWA7XG4gICAgICAgICAgICBvbkVycm9yKG5ldyBEYXRlRm9ybWF0RXJyb3IobXNnLCB0b2tlbiwgRGF0ZUZvcm1hdEVycm9yLldBUk5JTkcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZHMuaW5kZXhPZihmaWVsZCkgPT09IC0xKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKG5ldyBEYXRlRm9ybWF0RXJyb3IoYER1cGxpY2F0ZSAke2ZpZWxkfSB0b2tlbmAsIHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gY29tcGlsZU9wdGlvbnModG9rZW4sIChtc2csIGlzV2FybmluZykgPT4gb25FcnJvcihuZXcgRGF0ZUZvcm1hdEVycm9yKG1zZywgdG9rZW4sIGlzV2FybmluZykpKTtcbiAgICAgICAgaWYgKG9wdClcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgb3B0KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmNvbnN0IGZpZWxkcyA9IHtcbiAgICBHOiB7IGZpZWxkOiAnZXJhJywgZGVzYzogJ0VyYScgfSxcbiAgICB5OiB7IGZpZWxkOiAneWVhcicsIGRlc2M6ICdZZWFyJyB9LFxuICAgIFk6IHsgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ1llYXIgb2YgXCJXZWVrIG9mIFllYXJcIicgfSxcbiAgICB1OiB7IGZpZWxkOiAneWVhcicsIGRlc2M6ICdFeHRlbmRlZCB5ZWFyJyB9LFxuICAgIFU6IHsgZmllbGQ6ICd5ZWFyJywgZGVzYzogJ0N5Y2xpYyB5ZWFyIG5hbWUnIH0sXG4gICAgcjogeyBmaWVsZDogJ3llYXInLCBkZXNjOiAnUmVsYXRlZCBHcmVnb3JpYW4geWVhcicgfSxcbiAgICBROiB7IGZpZWxkOiAncXVhcnRlcicsIGRlc2M6ICdRdWFydGVyJyB9LFxuICAgIHE6IHsgZmllbGQ6ICdxdWFydGVyJywgZGVzYzogJ1N0YW5kLWFsb25lIHF1YXJ0ZXInIH0sXG4gICAgTTogeyBmaWVsZDogJ21vbnRoJywgZGVzYzogJ01vbnRoIGluIHllYXInIH0sXG4gICAgTDogeyBmaWVsZDogJ21vbnRoJywgZGVzYzogJ1N0YW5kLWFsb25lIG1vbnRoIGluIHllYXInIH0sXG4gICAgdzogeyBmaWVsZDogJ3dlZWsnLCBkZXNjOiAnV2VlayBvZiB5ZWFyJyB9LFxuICAgIFc6IHsgZmllbGQ6ICd3ZWVrJywgZGVzYzogJ1dlZWsgb2YgbW9udGgnIH0sXG4gICAgZDogeyBmaWVsZDogJ2RheScsIGRlc2M6ICdEYXkgaW4gbW9udGgnIH0sXG4gICAgRDogeyBmaWVsZDogJ2RheScsIGRlc2M6ICdEYXkgb2YgeWVhcicgfSxcbiAgICBGOiB7IGZpZWxkOiAnZGF5JywgZGVzYzogJ0RheSBvZiB3ZWVrIGluIG1vbnRoJyB9LFxuICAgIGc6IHsgZmllbGQ6ICdkYXknLCBkZXNjOiAnTW9kaWZpZWQganVsaWFuIGRheScgfSxcbiAgICBFOiB7IGZpZWxkOiAnd2Vla2RheScsIGRlc2M6ICdEYXkgb2Ygd2VlaycgfSxcbiAgICBlOiB7IGZpZWxkOiAnd2Vla2RheScsIGRlc2M6ICdMb2NhbCBkYXkgb2Ygd2VlaycgfSxcbiAgICBjOiB7IGZpZWxkOiAnd2Vla2RheScsIGRlc2M6ICdTdGFuZC1hbG9uZSBsb2NhbCBkYXkgb2Ygd2VlaycgfSxcbiAgICBhOiB7IGZpZWxkOiAncGVyaW9kJywgZGVzYzogJ0FNL1BNIG1hcmtlcicgfSxcbiAgICBiOiB7IGZpZWxkOiAncGVyaW9kJywgZGVzYzogJ0FNL1BNL25vb24vbWlkbmlnaHQgbWFya2VyJyB9LFxuICAgIEI6IHsgZmllbGQ6ICdwZXJpb2QnLCBkZXNjOiAnRmxleGlibGUgZGF5IHBlcmlvZCcgfSxcbiAgICBoOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIEFNL1BNICgxfjEyKScgfSxcbiAgICBIOiB7IGZpZWxkOiAnaG91cicsIGRlc2M6ICdIb3VyIGluIGRheSAoMH4yMyknIH0sXG4gICAgazogeyBmaWVsZDogJ2hvdXInLCBkZXNjOiAnSG91ciBpbiBkYXkgKDF+MjQpJyB9LFxuICAgIEs6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gQU0vUE0gKDB+MTEpJyB9LFxuICAgIGo6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gcHJlZmVycmVkIGN5Y2xlJyB9LFxuICAgIEo6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gcHJlZmVycmVkIGN5Y2xlIHdpdGhvdXQgbWFya2VyJyB9LFxuICAgIEM6IHsgZmllbGQ6ICdob3VyJywgZGVzYzogJ0hvdXIgaW4gcHJlZmVycmVkIGN5Y2xlIHdpdGggZmxleGlibGUgbWFya2VyJyB9LFxuICAgIG06IHsgZmllbGQ6ICdtaW4nLCBkZXNjOiAnTWludXRlIGluIGhvdXInIH0sXG4gICAgczogeyBmaWVsZDogJ3NlYycsIGRlc2M6ICdTZWNvbmQgaW4gbWludXRlJyB9LFxuICAgIFM6IHsgZmllbGQ6ICdzZWMtZnJhYycsIGRlc2M6ICdGcmFjdGlvbmFsIHNlY29uZCcgfSxcbiAgICBBOiB7IGZpZWxkOiAnbXMnLCBkZXNjOiAnTWlsbGlzZWNvbmRzIGluIGRheScgfSxcbiAgICB6OiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBzcGVjaWZpYyBub24tbG9jYXRpb24nIH0sXG4gICAgWjogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZScgfSxcbiAgICBPOiB7IGZpZWxkOiAndHonLCBkZXNjOiAnVGltZSBab25lOiBsb2NhbGl6ZWQnIH0sXG4gICAgdjogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogZ2VuZXJpYyBub24tbG9jYXRpb24nIH0sXG4gICAgVjogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogSUQnIH0sXG4gICAgWDogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogSVNPODYwMSB3aXRoIFonIH0sXG4gICAgeDogeyBmaWVsZDogJ3R6JywgZGVzYzogJ1RpbWUgWm9uZTogSVNPODYwMScgfVxufTtcbmNvbnN0IGlzTGV0dGVyID0gKGNoYXIpID0+IChjaGFyID49ICdBJyAmJiBjaGFyIDw9ICdaJykgfHwgKGNoYXIgPj0gJ2EnICYmIGNoYXIgPD0gJ3onKTtcbmZ1bmN0aW9uIHJlYWRGaWVsZFRva2VuKHNyYywgcG9zKSB7XG4gICAgY29uc3QgY2hhciA9IHNyY1twb3NdO1xuICAgIGxldCB3aWR0aCA9IDE7XG4gICAgd2hpbGUgKHNyY1srK3Bvc10gPT09IGNoYXIpXG4gICAgICAgICsrd2lkdGg7XG4gICAgY29uc3QgZmllbGQgPSBmaWVsZHNbY2hhcl07XG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgICBjb25zdCBtc2cgPSBgVGhlIGxldHRlciAke2NoYXJ9IGlzIG5vdCBhIHZhbGlkIGZpZWxkIGlkZW50aWZpZXJgO1xuICAgICAgICByZXR1cm4geyBjaGFyLCBlcnJvcjogbmV3IEVycm9yKG1zZyksIHdpZHRoIH07XG4gICAgfVxuICAgIHJldHVybiB7IGNoYXIsIGZpZWxkOiBmaWVsZC5maWVsZCwgZGVzYzogZmllbGQuZGVzYywgd2lkdGggfTtcbn1cbmZ1bmN0aW9uIHJlYWRRdW90ZWRUb2tlbihzcmMsIHBvcykge1xuICAgIGxldCBzdHIgPSBzcmNbKytwb3NdO1xuICAgIGxldCB3aWR0aCA9IDI7XG4gICAgaWYgKHN0ciA9PT0gXCInXCIpXG4gICAgICAgIHJldHVybiB7IGNoYXI6IFwiJ1wiLCBzdHIsIHdpZHRoIH07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHNyY1srK3Bvc107XG4gICAgICAgICsrd2lkdGg7XG4gICAgICAgIGlmIChuZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnRlcm1pbmF0ZWQgcXVvdGVkIGxpdGVyYWwgaW4gcGF0dGVybjogJHtzdHIgfHwgc3JjfWA7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFyOiBcIidcIiwgZXJyb3I6IG5ldyBFcnJvcihtc2cpLCBzdHIsIHdpZHRoIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIGlmIChzcmNbKytwb3NdICE9PSBcIidcIilcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFyOiBcIidcIiwgc3RyLCB3aWR0aCB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsrd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHNyYywgcG9zKSB7XG4gICAgY29uc3QgY2hhciA9IHNyY1twb3NdO1xuICAgIGlmICghY2hhcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlzTGV0dGVyKGNoYXIpKVxuICAgICAgICByZXR1cm4gcmVhZEZpZWxkVG9rZW4oc3JjLCBwb3MpO1xuICAgIGlmIChjaGFyID09PSBcIidcIilcbiAgICAgICAgcmV0dXJuIHJlYWRRdW90ZWRUb2tlbihzcmMsIHBvcyk7XG4gICAgbGV0IHN0ciA9IGNoYXI7XG4gICAgbGV0IHdpZHRoID0gMTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gc3JjWysrcG9zXTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IGlzTGV0dGVyKG5leHQpIHx8IG5leHQgPT09IFwiJ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHsgY2hhciwgc3RyLCB3aWR0aCB9O1xuICAgICAgICBzdHIgKz0gbmV4dDtcbiAgICAgICAgd2lkdGggKz0gMTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIGFuIHtAbGluayBodHRwOi8vdXNlcmd1aWRlLmljdS1wcm9qZWN0Lm9yZy9mb3JtYXRwYXJzZS9kYXRldGltZSB8IElDVVxuICogRGF0ZUZvcm1hdCBza2VsZXRvbn0gc3RyaW5nIGludG8gYSB7QGxpbmsgRGF0ZVRva2VufSBhcnJheS5cbiAqXG4gKiBAcmVtYXJrc1xuICogRXJyb3JzIHdpbGwgbm90IGJlIHRocm93biwgYnV0IGlmIGVuY291bnRlcmVkIGFyZSBpbmNsdWRlZCBhcyB0aGUgcmVsZXZhbnRcbiAqIHRva2VuJ3MgYGVycm9yYCB2YWx1ZS5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc3JjIC0gVGhlIHNrZWxldG9uIHN0cmluZ1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgcGFyc2VEYXRlVG9rZW5zIH0gZnJvbSAnQG1lc3NhZ2Vmb3JtYXQvZGF0ZS1za2VsZXRvbidcbiAqXG4gKiBwYXJzZURhdGVUb2tlbnMoJ0dyTU1NZGQnLCBjb25zb2xlLmVycm9yKVxuICogLy8gW1xuICogLy8gICB7IGNoYXI6ICdHJywgZmllbGQ6ICdlcmEnLCBkZXNjOiAnRXJhJywgd2lkdGg6IDEgfSxcbiAqIC8vICAgeyBjaGFyOiAncicsIGZpZWxkOiAneWVhcicsIGRlc2M6ICdSZWxhdGVkIEdyZWdvcmlhbiB5ZWFyJywgd2lkdGg6IDEgfSxcbiAqIC8vICAgeyBjaGFyOiAnTScsIGZpZWxkOiAnbW9udGgnLCBkZXNjOiAnTW9udGggaW4geWVhcicsIHdpZHRoOiAzIH0sXG4gKiAvLyAgIHsgY2hhcjogJ2QnLCBmaWVsZDogJ2RheScsIGRlc2M6ICdEYXkgaW4gbW9udGgnLCB3aWR0aDogMiB9XG4gKiAvLyBdXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRlVG9rZW5zKHNyYykge1xuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcmVhZFRva2VuKHNyYywgcG9zKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgcG9zICs9IHRva2VuLndpZHRoO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Rva2Vucyh0b2tlbnMsIG1hcFRleHQpIHtcbiAgaWYgKCF0b2tlbnMuZmlsdGVyKCh0b2tlbikgPT4gdG9rZW4udHlwZSAhPT0gXCJjb250ZW50XCIpLmxlbmd0aCkge1xuICAgIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4gbWFwVGV4dCh0b2tlbi52YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgIGlmICh0b2tlbi50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIG1hcFRleHQodG9rZW4udmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gXCJvY3RvdGhvcnBlXCIpIHtcbiAgICAgIHJldHVybiBcIiNcIjtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IFwiYXJndW1lbnRcIikge1xuICAgICAgcmV0dXJuIFt0b2tlbi5hcmddO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBfcGFyYW0gPSB0b2tlbj8ucGFyYW0/LlswXTtcbiAgICAgIGlmICh0b2tlbi5rZXkgPT09IFwiZGF0ZVwiICYmIF9wYXJhbSkge1xuICAgICAgICBjb25zdCBvcHRzID0gY29tcGlsZURhdGVFeHByZXNzaW9uKF9wYXJhbS52YWx1ZS50cmltKCksIChlKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29tcGlsZSBkYXRlIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFt0b2tlbi5hcmcsIHRva2VuLmtleSwgb3B0c107XG4gICAgICB9XG4gICAgICBpZiAoX3BhcmFtKSB7XG4gICAgICAgIHJldHVybiBbdG9rZW4uYXJnLCB0b2tlbi5rZXksIF9wYXJhbS52YWx1ZS50cmltKCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt0b2tlbi5hcmcsIHRva2VuLmtleV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IHRva2VuLnBsdXJhbE9mZnNldDtcbiAgICBjb25zdCBmb3JtYXRQcm9wcyA9IHt9O1xuICAgIHRva2VuLmNhc2VzLmZvckVhY2goKHsga2V5LCB0b2tlbnM6IHRva2VuczIgfSkgPT4ge1xuICAgICAgY29uc3QgcHJvcCA9IGtleVswXSA9PT0gXCI9XCIgPyBrZXkuc2xpY2UoMSkgOiBrZXk7XG4gICAgICBmb3JtYXRQcm9wc1twcm9wXSA9IHByb2Nlc3NUb2tlbnModG9rZW5zMiwgbWFwVGV4dCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRva2VuLmFyZyxcbiAgICAgIHRva2VuLnR5cGUsXG4gICAgICB7XG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgLi4uZm9ybWF0UHJvcHNcbiAgICAgIH1cbiAgICBdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVEYXRlRXhwcmVzc2lvbihmb3JtYXQsIG9uRXJyb3IpIHtcbiAgaWYgKC9eOjovLnRlc3QoZm9ybWF0KSkge1xuICAgIGNvbnN0IHRva2VucyA9IHBhcnNlRGF0ZVRva2Vucyhmb3JtYXQuc3Vic3RyaW5nKDIpKTtcbiAgICByZXR1cm4gZ2V0RGF0ZUZvcm1hdE9wdGlvbnModG9rZW5zLCB2b2lkIDAsIG9uRXJyb3IpO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiBjb21waWxlTWVzc2FnZShtZXNzYWdlLCBtYXBUZXh0ID0gKHYpID0+IHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzc1Rva2VucyhwYXJzZShtZXNzYWdlKSwgbWFwVGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKGAke2UubWVzc2FnZX0gXG5cbk1lc3NhZ2U6ICR7bWVzc2FnZX1gKTtcbiAgICByZXR1cm4gW21lc3NhZ2VdO1xuICB9XG59XG5cbmV4cG9ydCB7IGNvbXBpbGVNZXNzYWdlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/message-utils/dist/compileMessage.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@lingui/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nProvider: () => (/* binding */ I18nProvider),\n/* harmony export */   LinguiContext: () => (/* binding */ LinguiContext),\n/* harmony export */   Trans: () => (/* binding */ Trans),\n/* harmony export */   useLingui: () => (/* binding */ useLingui)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _shared_react_31c3b5fa_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/react.31c3b5fa.mjs */ \"(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs\");\n/* __next_internal_client_entry_do_not_use__ I18nProvider,LinguiContext,Trans,useLingui auto */ \n\nconst LinguiContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useLinguiInternal = (devErrorMessage)=>{\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LinguiContext);\n    if (true) {\n        if (context == null) {\n            throw new Error(devErrorMessage ?? \"useLingui hook was used without I18nProvider.\");\n        }\n    }\n    return context;\n};\nfunction useLingui() {\n    return useLinguiInternal();\n}\nconst I18nProvider = ({ i18n, defaultComponent, children })=>{\n    const latestKnownLocale = react__WEBPACK_IMPORTED_MODULE_0__.useRef(i18n.locale);\n    const makeContext = react__WEBPACK_IMPORTED_MODULE_0__.useCallback({\n        \"I18nProvider.useCallback[makeContext]\": ()=>({\n                i18n,\n                defaultComponent,\n                _: i18n.t.bind(i18n)\n            })\n    }[\"I18nProvider.useCallback[makeContext]\"], [\n        i18n,\n        defaultComponent\n    ]);\n    const [context, setContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState(makeContext());\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect({\n        \"I18nProvider.useEffect\": ()=>{\n            const updateContext = {\n                \"I18nProvider.useEffect.updateContext\": ()=>{\n                    latestKnownLocale.current = i18n.locale;\n                    setContext(makeContext());\n                }\n            }[\"I18nProvider.useEffect.updateContext\"];\n            const unsubscribe = i18n.on(\"change\", updateContext);\n            if (latestKnownLocale.current !== i18n.locale) {\n                updateContext();\n            }\n            return unsubscribe;\n        }\n    }[\"I18nProvider.useEffect\"], [\n        i18n,\n        makeContext\n    ]);\n    if (!latestKnownLocale.current) {\n         true && console.log(\"I18nProvider rendered `null`. A call to `i18n.activate` needs to happen in order for translations to be activated and for the I18nProvider to render.This is not an error but an informational message logged only in development.\");\n        return null;\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LinguiContext.Provider, {\n        value: context\n    }, children);\n};\nfunction Trans(props) {\n    let errMessage = void 0;\n    if (true) {\n        errMessage = `Trans component was rendered without I18nProvider.\nAttempted to render message: ${props.message} id: ${props.id}. Make sure this component is rendered inside a I18nProvider.`;\n    }\n    const lingui = useLinguiInternal(errMessage);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_shared_react_31c3b5fa_mjs__WEBPACK_IMPORTED_MODULE_1__.T, {\n        ...props,\n        lingui\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Z0dBQzBCO0FBQ3dDO0FBRWxFLE1BQU1HLDhCQUFnQkgsZ0RBQW1CLENBQUM7QUFDMUMsTUFBTUssb0JBQW9CLENBQUNDO0lBQ3pCLE1BQU1DLFVBQVVQLDZDQUFnQixDQUFDRztJQUNqQyxJQUFJTSxJQUFxQyxFQUFFO1FBQ3pDLElBQUlGLFdBQVcsTUFBTTtZQUNuQixNQUFNLElBQUlHLE1BQ1JKLG1CQUFtQjtRQUV2QjtJQUNGO0lBQ0EsT0FBT0M7QUFDVDtBQUNBLFNBQVNJO0lBQ1AsT0FBT047QUFDVDtBQUNBLE1BQU1PLGVBQWUsQ0FBQyxFQUNwQkMsSUFBSSxFQUNKQyxnQkFBZ0IsRUFDaEJDLFFBQVEsRUFDVDtJQUNDLE1BQU1DLG9CQUFvQmhCLHlDQUFZLENBQUNhLEtBQUtLLE1BQU07SUFDbEQsTUFBTUMsY0FBY25CLDhDQUFpQjtpREFDbkMsSUFBTztnQkFDTGE7Z0JBQ0FDO2dCQUNBTyxHQUFHUixLQUFLUyxDQUFDLENBQUNDLElBQUksQ0FBQ1Y7WUFDakI7Z0RBQ0E7UUFBQ0E7UUFBTUM7S0FBaUI7SUFFMUIsTUFBTSxDQUFDUCxTQUFTaUIsV0FBVyxHQUFHeEIsMkNBQWMsQ0FBQ21CO0lBQzdDbkIsNENBQWU7a0NBQUM7WUFDZCxNQUFNMkI7d0RBQWdCO29CQUNwQlgsa0JBQWtCWSxPQUFPLEdBQUdmLEtBQUtLLE1BQU07b0JBQ3ZDTSxXQUFXTDtnQkFDYjs7WUFDQSxNQUFNVSxjQUFjaEIsS0FBS2lCLEVBQUUsQ0FBQyxVQUFVSDtZQUN0QyxJQUFJWCxrQkFBa0JZLE9BQU8sS0FBS2YsS0FBS0ssTUFBTSxFQUFFO2dCQUM3Q1M7WUFDRjtZQUNBLE9BQU9FO1FBQ1Q7aUNBQUc7UUFBQ2hCO1FBQU1NO0tBQVk7SUFDdEIsSUFBSSxDQUFDSCxrQkFBa0JZLE9BQU8sRUFBRTthQUNRLElBQUlHLFFBQVFDLEdBQUcsQ0FDbkQ7UUFFRixPQUFPO0lBQ1Q7SUFDQSxPQUFPLGFBQWEsaUJBQUdoQyxnREFBbUIsQ0FBQ0csY0FBYytCLFFBQVEsRUFBRTtRQUFFQyxPQUFPNUI7SUFBUSxHQUFHUTtBQUN6RjtBQUVBLFNBQVNxQixNQUFNQyxLQUFLO0lBQ2xCLElBQUlDLGFBQWEsS0FBSztJQUN0QixJQUFJN0IsSUFBcUMsRUFBRTtRQUN6QzZCLGFBQWEsQ0FBQzs2QkFDVyxFQUFFRCxNQUFNRSxPQUFPLENBQUMsS0FBSyxFQUFFRixNQUFNRyxFQUFFLENBQUMsNkRBQTZELENBQUM7SUFDekg7SUFDQSxNQUFNQyxTQUFTcEMsa0JBQWtCaUM7SUFDakMscUJBQU90QyxnREFBbUIsQ0FBQ0UseURBQWNBLEVBQUU7UUFBRSxHQUFHbUMsS0FBSztRQUFFSTtJQUFPO0FBQ2hFO0FBRXlEIiwic291cmNlcyI6WyJQOlxcR2FsZW9uIHByb2plY3RzXFxnYWxlb24tY29tbXVuaXR5LWhvc3BpdGFsLW1hcFxcbWFpblxcbm9kZV9tb2R1bGVzXFxAbGluZ3VpXFxyZWFjdFxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUIGFzIFRyYW5zTm9Db250ZXh0IH0gZnJvbSAnLi9zaGFyZWQvcmVhY3QuMzFjM2I1ZmEubWpzJztcblxuY29uc3QgTGluZ3VpQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VMaW5ndWlJbnRlcm5hbCA9IChkZXZFcnJvck1lc3NhZ2UpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoTGluZ3VpQ29udGV4dCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGRldkVycm9yTWVzc2FnZSA/PyBcInVzZUxpbmd1aSBob29rIHdhcyB1c2VkIHdpdGhvdXQgSTE4blByb3ZpZGVyLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5mdW5jdGlvbiB1c2VMaW5ndWkoKSB7XG4gIHJldHVybiB1c2VMaW5ndWlJbnRlcm5hbCgpO1xufVxuY29uc3QgSTE4blByb3ZpZGVyID0gKHtcbiAgaTE4bixcbiAgZGVmYXVsdENvbXBvbmVudCxcbiAgY2hpbGRyZW5cbn0pID0+IHtcbiAgY29uc3QgbGF0ZXN0S25vd25Mb2NhbGUgPSBSZWFjdC51c2VSZWYoaTE4bi5sb2NhbGUpO1xuICBjb25zdCBtYWtlQ29udGV4dCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICgpID0+ICh7XG4gICAgICBpMThuLFxuICAgICAgZGVmYXVsdENvbXBvbmVudCxcbiAgICAgIF86IGkxOG4udC5iaW5kKGkxOG4pXG4gICAgfSksXG4gICAgW2kxOG4sIGRlZmF1bHRDb21wb25lbnRdXG4gICk7XG4gIGNvbnN0IFtjb250ZXh0LCBzZXRDb250ZXh0XSA9IFJlYWN0LnVzZVN0YXRlKG1ha2VDb250ZXh0KCkpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZUNvbnRleHQgPSAoKSA9PiB7XG4gICAgICBsYXRlc3RLbm93bkxvY2FsZS5jdXJyZW50ID0gaTE4bi5sb2NhbGU7XG4gICAgICBzZXRDb250ZXh0KG1ha2VDb250ZXh0KCkpO1xuICAgIH07XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBpMThuLm9uKFwiY2hhbmdlXCIsIHVwZGF0ZUNvbnRleHQpO1xuICAgIGlmIChsYXRlc3RLbm93bkxvY2FsZS5jdXJyZW50ICE9PSBpMThuLmxvY2FsZSkge1xuICAgICAgdXBkYXRlQ29udGV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtpMThuLCBtYWtlQ29udGV4dF0pO1xuICBpZiAoIWxhdGVzdEtub3duTG9jYWxlLmN1cnJlbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIGNvbnNvbGUubG9nKFxuICAgICAgXCJJMThuUHJvdmlkZXIgcmVuZGVyZWQgYG51bGxgLiBBIGNhbGwgdG8gYGkxOG4uYWN0aXZhdGVgIG5lZWRzIHRvIGhhcHBlbiBpbiBvcmRlciBmb3IgdHJhbnNsYXRpb25zIHRvIGJlIGFjdGl2YXRlZCBhbmQgZm9yIHRoZSBJMThuUHJvdmlkZXIgdG8gcmVuZGVyLlRoaXMgaXMgbm90IGFuIGVycm9yIGJ1dCBhbiBpbmZvcm1hdGlvbmFsIG1lc3NhZ2UgbG9nZ2VkIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXCJcbiAgICApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5ndWlDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKTtcbn07XG5cbmZ1bmN0aW9uIFRyYW5zKHByb3BzKSB7XG4gIGxldCBlcnJNZXNzYWdlID0gdm9pZCAwO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyTWVzc2FnZSA9IGBUcmFucyBjb21wb25lbnQgd2FzIHJlbmRlcmVkIHdpdGhvdXQgSTE4blByb3ZpZGVyLlxuQXR0ZW1wdGVkIHRvIHJlbmRlciBtZXNzYWdlOiAke3Byb3BzLm1lc3NhZ2V9IGlkOiAke3Byb3BzLmlkfS4gTWFrZSBzdXJlIHRoaXMgY29tcG9uZW50IGlzIHJlbmRlcmVkIGluc2lkZSBhIEkxOG5Qcm92aWRlci5gO1xuICB9XG4gIGNvbnN0IGxpbmd1aSA9IHVzZUxpbmd1aUludGVybmFsKGVyck1lc3NhZ2UpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc05vQ29udGV4dCwgeyAuLi5wcm9wcywgbGluZ3VpIH0pO1xufVxuXG5leHBvcnQgeyBJMThuUHJvdmlkZXIsIExpbmd1aUNvbnRleHQsIFRyYW5zLCB1c2VMaW5ndWkgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlQiLCJUcmFuc05vQ29udGV4dCIsIkxpbmd1aUNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlTGluZ3VpSW50ZXJuYWwiLCJkZXZFcnJvck1lc3NhZ2UiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsInByb2Nlc3MiLCJFcnJvciIsInVzZUxpbmd1aSIsIkkxOG5Qcm92aWRlciIsImkxOG4iLCJkZWZhdWx0Q29tcG9uZW50IiwiY2hpbGRyZW4iLCJsYXRlc3RLbm93bkxvY2FsZSIsInVzZVJlZiIsImxvY2FsZSIsIm1ha2VDb250ZXh0IiwidXNlQ2FsbGJhY2siLCJfIiwidCIsImJpbmQiLCJzZXRDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1cGRhdGVDb250ZXh0IiwiY3VycmVudCIsInVuc3Vic2NyaWJlIiwib24iLCJjb25zb2xlIiwibG9nIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJUcmFucyIsInByb3BzIiwiZXJyTWVzc2FnZSIsIm1lc3NhZ2UiLCJpZCIsImxpbmd1aSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   T: () => (/* binding */ TransNoContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n\n\nconst tagRe = /<([a-zA-Z0-9]+)>([\\s\\S]*?)<\\/\\1>|<([a-zA-Z0-9]+)\\/>/;\nconst voidElementTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true,\n  menuitem: true\n};\nfunction formatElements(value, elements = {}) {\n  const uniqueId = makeCounter(0, \"$lingui$\");\n  const parts = value.split(tagRe);\n  if (parts.length === 1)\n    return value;\n  const tree = [];\n  const before = parts.shift();\n  if (before)\n    tree.push(before);\n  for (const [index, children, after] of getElements(parts)) {\n    let element = typeof index !== \"undefined\" ? elements[index] : void 0;\n    if (!element || voidElementTags[element.type] && children) {\n      if (!element) {\n        console.error(\n          `Can't use element at index '${index}' as it is not declared in the original translation`\n        );\n      } else {\n        console.error(\n          `${element.type} is a void element tag therefore it must have no children`\n        );\n      }\n      element = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment);\n    }\n    if (Array.isArray(element)) {\n      element = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, element);\n    }\n    tree.push(\n      react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(\n        element,\n        { key: uniqueId() },\n        // format children for pair tags\n        // unpaired tags might have children if it's a component passed as a variable\n        children ? formatElements(children, elements) : element.props.children\n      )\n    );\n    if (after)\n      tree.push(after);\n  }\n  return tree.length === 1 ? tree[0] : tree;\n}\nfunction getElements(parts) {\n  if (!parts.length)\n    return [];\n  const [paired, children, unpaired, after] = parts.slice(0, 4);\n  const triple = [paired || unpaired, children || \"\", after];\n  return [triple].concat(getElements(parts.slice(4, parts.length)));\n}\nconst makeCounter = (count = 0, prefix = \"\") => () => `${prefix}_${count++}`;\n\nfunction TransNoContext(props) {\n  const {\n    render,\n    component,\n    id,\n    message,\n    formats,\n    lingui: { i18n, defaultComponent }\n  } = props;\n  const values = { ...props.values };\n  const components = { ...props.components };\n  if (values) {\n    Object.keys(values).forEach((key) => {\n      const index = Object.keys(components).length;\n      if (typeof values[key] === \"string\" || typeof values[key] === \"number\") {\n        return;\n      }\n      components[index] = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, values[key]);\n      values[key] = `<${index}/>`;\n    });\n  }\n  const _translation = i18n && typeof i18n._ === \"function\" ? i18n._(id, values, { message, formats }) : id;\n  const translation = _translation ? formatElements(_translation, components) : null;\n  if (render === null || component === null) {\n    return translation;\n  }\n  const FallbackComponent = defaultComponent || RenderFragment;\n  const i18nProps = {\n    id,\n    message,\n    translation,\n    children: translation\n    // for type-compatibility with `component` prop\n  };\n  if (render && component) {\n    console.error(\n      \"You can't use both `component` and `render` prop at the same time. `component` is ignored.\"\n    );\n  } else if (render && typeof render !== \"function\") {\n    console.error(\n      `Invalid value supplied to prop \\`render\\`. It must be a function, provided ${render}`\n    );\n  } else if (component && typeof component !== \"function\") {\n    console.error(\n      `Invalid value supplied to prop \\`component\\`. It must be a React component, provided ${component}`\n    );\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, i18nProps, translation);\n  }\n  if (typeof render === \"function\") {\n    return render(i18nProps);\n  }\n  const Component = component || FallbackComponent;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, i18nProps, translation);\n}\nconst RenderFragment = ({ children }) => {\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxpbmd1aS9yZWFjdC9kaXN0L3NoYXJlZC9yZWFjdC4zMWMzYjVmYS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE1BQU07QUFDL0M7QUFDQSxRQUFRO0FBQ1I7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixnREFBbUIsQ0FBQywyQ0FBYztBQUNsRDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFtQixDQUFDLDJDQUFjLElBQUk7QUFDdEQ7QUFDQTtBQUNBLE1BQU0sK0NBQWtCO0FBQ3hCO0FBQ0EsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLEdBQUcsUUFBUTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsSUFBSTtBQUNKLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdEQUFtQixDQUFDLDJDQUFjO0FBQzVFLHdCQUF3QixNQUFNO0FBQzlCLEtBQUs7QUFDTDtBQUNBLG1GQUFtRixrQkFBa0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvRkFBb0YsT0FBTztBQUMzRjtBQUNBLElBQUk7QUFDSjtBQUNBLDhGQUE4RixVQUFVO0FBQ3hHO0FBQ0EsV0FBVyxnREFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQW1CO0FBQzVCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEMseUJBQXlCLGdEQUFtQixDQUFDLDJDQUFjO0FBQzNEOztBQUUrQiIsInNvdXJjZXMiOlsiUDpcXEdhbGVvbiBwcm9qZWN0c1xcZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXBcXG1haW5cXG5vZGVfbW9kdWxlc1xcQGxpbmd1aVxccmVhY3RcXGRpc3RcXHNoYXJlZFxccmVhY3QuMzFjM2I1ZmEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHRhZ1JlID0gLzwoW2EtekEtWjAtOV0rKT4oW1xcc1xcU10qPyk8XFwvXFwxPnw8KFthLXpBLVowLTldKylcXC8+LztcbmNvbnN0IHZvaWRFbGVtZW50VGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUsXG4gIG1lbnVpdGVtOiB0cnVlXG59O1xuZnVuY3Rpb24gZm9ybWF0RWxlbWVudHModmFsdWUsIGVsZW1lbnRzID0ge30pIHtcbiAgY29uc3QgdW5pcXVlSWQgPSBtYWtlQ291bnRlcigwLCBcIiRsaW5ndWkkXCIpO1xuICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KHRhZ1JlKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHRyZWUgPSBbXTtcbiAgY29uc3QgYmVmb3JlID0gcGFydHMuc2hpZnQoKTtcbiAgaWYgKGJlZm9yZSlcbiAgICB0cmVlLnB1c2goYmVmb3JlKTtcbiAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkcmVuLCBhZnRlcl0gb2YgZ2V0RWxlbWVudHMocGFydHMpKSB7XG4gICAgbGV0IGVsZW1lbnQgPSB0eXBlb2YgaW5kZXggIT09IFwidW5kZWZpbmVkXCIgPyBlbGVtZW50c1tpbmRleF0gOiB2b2lkIDA7XG4gICAgaWYgKCFlbGVtZW50IHx8IHZvaWRFbGVtZW50VGFnc1tlbGVtZW50LnR5cGVdICYmIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgQ2FuJ3QgdXNlIGVsZW1lbnQgYXQgaW5kZXggJyR7aW5kZXh9JyBhcyBpdCBpcyBub3QgZGVjbGFyZWQgaW4gdGhlIG9yaWdpbmFsIHRyYW5zbGF0aW9uYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgJHtlbGVtZW50LnR5cGV9IGlzIGEgdm9pZCBlbGVtZW50IHRhZyB0aGVyZWZvcmUgaXQgbXVzdCBoYXZlIG5vIGNoaWxkcmVuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHt9LCBlbGVtZW50KTtcbiAgICB9XG4gICAgdHJlZS5wdXNoKFxuICAgICAgUmVhY3QuY2xvbmVFbGVtZW50KFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICB7IGtleTogdW5pcXVlSWQoKSB9LFxuICAgICAgICAvLyBmb3JtYXQgY2hpbGRyZW4gZm9yIHBhaXIgdGFnc1xuICAgICAgICAvLyB1bnBhaXJlZCB0YWdzIG1pZ2h0IGhhdmUgY2hpbGRyZW4gaWYgaXQncyBhIGNvbXBvbmVudCBwYXNzZWQgYXMgYSB2YXJpYWJsZVxuICAgICAgICBjaGlsZHJlbiA/IGZvcm1hdEVsZW1lbnRzKGNoaWxkcmVuLCBlbGVtZW50cykgOiBlbGVtZW50LnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgICBpZiAoYWZ0ZXIpXG4gICAgICB0cmVlLnB1c2goYWZ0ZXIpO1xuICB9XG4gIHJldHVybiB0cmVlLmxlbmd0aCA9PT0gMSA/IHRyZWVbMF0gOiB0cmVlO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudHMocGFydHMpIHtcbiAgaWYgKCFwYXJ0cy5sZW5ndGgpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBbcGFpcmVkLCBjaGlsZHJlbiwgdW5wYWlyZWQsIGFmdGVyXSA9IHBhcnRzLnNsaWNlKDAsIDQpO1xuICBjb25zdCB0cmlwbGUgPSBbcGFpcmVkIHx8IHVucGFpcmVkLCBjaGlsZHJlbiB8fCBcIlwiLCBhZnRlcl07XG4gIHJldHVybiBbdHJpcGxlXS5jb25jYXQoZ2V0RWxlbWVudHMocGFydHMuc2xpY2UoNCwgcGFydHMubGVuZ3RoKSkpO1xufVxuY29uc3QgbWFrZUNvdW50ZXIgPSAoY291bnQgPSAwLCBwcmVmaXggPSBcIlwiKSA9PiAoKSA9PiBgJHtwcmVmaXh9XyR7Y291bnQrK31gO1xuXG5mdW5jdGlvbiBUcmFuc05vQ29udGV4dChwcm9wcykge1xuICBjb25zdCB7XG4gICAgcmVuZGVyLFxuICAgIGNvbXBvbmVudCxcbiAgICBpZCxcbiAgICBtZXNzYWdlLFxuICAgIGZvcm1hdHMsXG4gICAgbGluZ3VpOiB7IGkxOG4sIGRlZmF1bHRDb21wb25lbnQgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHZhbHVlcyA9IHsgLi4ucHJvcHMudmFsdWVzIH07XG4gIGNvbnN0IGNvbXBvbmVudHMgPSB7IC4uLnByb3BzLmNvbXBvbmVudHMgfTtcbiAgaWYgKHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpLmxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlc1trZXldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbXBvbmVudHNbaW5kZXhdID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHZhbHVlc1trZXldKTtcbiAgICAgIHZhbHVlc1trZXldID0gYDwke2luZGV4fS8+YDtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBfdHJhbnNsYXRpb24gPSBpMThuICYmIHR5cGVvZiBpMThuLl8gPT09IFwiZnVuY3Rpb25cIiA/IGkxOG4uXyhpZCwgdmFsdWVzLCB7IG1lc3NhZ2UsIGZvcm1hdHMgfSkgOiBpZDtcbiAgY29uc3QgdHJhbnNsYXRpb24gPSBfdHJhbnNsYXRpb24gPyBmb3JtYXRFbGVtZW50cyhfdHJhbnNsYXRpb24sIGNvbXBvbmVudHMpIDogbnVsbDtcbiAgaWYgKHJlbmRlciA9PT0gbnVsbCB8fCBjb21wb25lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJhbnNsYXRpb247XG4gIH1cbiAgY29uc3QgRmFsbGJhY2tDb21wb25lbnQgPSBkZWZhdWx0Q29tcG9uZW50IHx8IFJlbmRlckZyYWdtZW50O1xuICBjb25zdCBpMThuUHJvcHMgPSB7XG4gICAgaWQsXG4gICAgbWVzc2FnZSxcbiAgICB0cmFuc2xhdGlvbixcbiAgICBjaGlsZHJlbjogdHJhbnNsYXRpb25cbiAgICAvLyBmb3IgdHlwZS1jb21wYXRpYmlsaXR5IHdpdGggYGNvbXBvbmVudGAgcHJvcFxuICB9O1xuICBpZiAocmVuZGVyICYmIGNvbXBvbmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIllvdSBjYW4ndCB1c2UgYm90aCBgY29tcG9uZW50YCBhbmQgYHJlbmRlcmAgcHJvcCBhdCB0aGUgc2FtZSB0aW1lLiBgY29tcG9uZW50YCBpcyBpZ25vcmVkLlwiXG4gICAgKTtcbiAgfSBlbHNlIGlmIChyZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIHRvIHByb3AgXFxgcmVuZGVyXFxgLiBJdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHByb3ZpZGVkICR7cmVuZGVyfWBcbiAgICApO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgc3VwcGxpZWQgdG8gcHJvcCBcXGBjb21wb25lbnRcXGAuIEl0IG11c3QgYmUgYSBSZWFjdCBjb21wb25lbnQsIHByb3ZpZGVkICR7Y29tcG9uZW50fWBcbiAgICApO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBpMThuUHJvcHMsIHRyYW5zbGF0aW9uKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHJlbmRlcihpMThuUHJvcHMpO1xuICB9XG4gIGNvbnN0IENvbXBvbmVudCA9IGNvbXBvbmVudCB8fCBGYWxsYmFja0NvbXBvbmVudDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBpMThuUHJvcHMsIHRyYW5zbGF0aW9uKTtcbn1cbmNvbnN0IFJlbmRlckZyYWdtZW50ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydCB7IFRyYW5zTm9Db250ZXh0IGFzIFQgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lingui/react/dist/shared/react.31c3b5fa.mjs\n");

/***/ })

};
;