"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@messageformat";
exports.ids = ["vendor-chunks/@messageformat"];
exports.modules = {

/***/ "(ssr)/./node_modules/@messageformat/parser/lib/lexer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@messageformat/parser/lib/lexer.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.lexer = exports.states = void 0;\nconst moo_1 = __importDefault(__webpack_require__(/*! moo */ \"(ssr)/./node_modules/moo/moo.js\"));\nexports.states = {\n    body: {\n        doubleapos: { match: \"''\", value: () => \"'\" },\n        quoted: {\n            lineBreaks: true,\n            match: /'[{}#](?:[^']|'')*'(?!')/u,\n            value: src => src.slice(1, -1).replace(/''/g, \"'\")\n        },\n        argument: {\n            lineBreaks: true,\n            match: /\\{\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            push: 'arg',\n            value: src => src.substring(1).trim()\n        },\n        octothorpe: '#',\n        end: { match: '}', pop: 1 },\n        content: { lineBreaks: true, match: /[^][^{}#']*/u }\n    },\n    arg: {\n        select: {\n            lineBreaks: true,\n            match: /,\\s*(?:plural|select|selectordinal)\\s*,\\s*/u,\n            next: 'select',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-args': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*,/u,\n            next: 'body',\n            value: src => src.split(',')[1].trim()\n        },\n        'func-simple': {\n            lineBreaks: true,\n            match: /,\\s*[^\\p{Pat_Syn}\\p{Pat_WS}]+\\s*/u,\n            value: src => src.substring(1).trim()\n        },\n        end: { match: '}', pop: 1 }\n    },\n    select: {\n        offset: {\n            lineBreaks: true,\n            match: /\\s*offset\\s*:\\s*\\d+\\s*/u,\n            value: src => src.split(':')[1].trim()\n        },\n        case: {\n            lineBreaks: true,\n            match: /\\s*(?:=\\d+|[^\\p{Pat_Syn}\\p{Pat_WS}]+)\\s*\\{/u,\n            push: 'body',\n            value: src => src.substring(0, src.indexOf('{')).trim()\n        },\n        end: { match: /\\s*\\}/u, pop: 1 }\n    }\n};\nexports.lexer = moo_1.default.states(exports.states);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyL2xpYi9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxjQUFjO0FBQzlCLDhCQUE4QixtQkFBTyxDQUFDLDRDQUFLO0FBQzNDLGNBQWM7QUFDZDtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsUUFBUSxHQUFHLE9BQU87QUFDaEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGVBQWUsU0FBUyxXQUFXO0FBQ25DLG1CQUFtQixpQ0FBaUM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCLFFBQVEsR0FBRyxPQUFPO0FBQy9DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2QixRQUFRLEdBQUcsT0FBTztBQUMvQztBQUNBLFNBQVM7QUFDVCxlQUFlLFNBQVM7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLEdBQUcsT0FBTyxRQUFRO0FBQzlEO0FBQ0EseURBQXlEO0FBQ3pELFNBQVM7QUFDVCxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9kYXRhL1Byb2plY3RzL0dhbGVvbiBwcm9qZWN0cy9nYWxlb24tY29tbXVuaXR5LWhvc3BpdGFsLW1hcC9tYWluL25vZGVfbW9kdWxlcy9AbWVzc2FnZWZvcm1hdC9wYXJzZXIvbGliL2xleGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sZXhlciA9IGV4cG9ydHMuc3RhdGVzID0gdm9pZCAwO1xuY29uc3QgbW9vXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1vb1wiKSk7XG5leHBvcnRzLnN0YXRlcyA9IHtcbiAgICBib2R5OiB7XG4gICAgICAgIGRvdWJsZWFwb3M6IHsgbWF0Y2g6IFwiJydcIiwgdmFsdWU6ICgpID0+IFwiJ1wiIH0sXG4gICAgICAgIHF1b3RlZDoge1xuICAgICAgICAgICAgbGluZUJyZWFrczogdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoOiAvJ1t7fSNdKD86W14nXXwnJykqJyg/IScpL3UsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zbGljZSgxLCAtMSkucmVwbGFjZSgvJycvZywgXCInXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGFyZ3VtZW50OiB7XG4gICAgICAgICAgICBsaW5lQnJlYWtzOiB0cnVlLFxuICAgICAgICAgICAgbWF0Y2g6IC9cXHtcXHMqW15cXHB7UGF0X1N5bn1cXHB7UGF0X1dTfV0rXFxzKi91LFxuICAgICAgICAgICAgcHVzaDogJ2FyZycsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zdWJzdHJpbmcoMSkudHJpbSgpXG4gICAgICAgIH0sXG4gICAgICAgIG9jdG90aG9ycGU6ICcjJyxcbiAgICAgICAgZW5kOiB7IG1hdGNoOiAnfScsIHBvcDogMSB9LFxuICAgICAgICBjb250ZW50OiB7IGxpbmVCcmVha3M6IHRydWUsIG1hdGNoOiAvW15dW157fSMnXSovdSB9XG4gICAgfSxcbiAgICBhcmc6IHtcbiAgICAgICAgc2VsZWN0OiB7XG4gICAgICAgICAgICBsaW5lQnJlYWtzOiB0cnVlLFxuICAgICAgICAgICAgbWF0Y2g6IC8sXFxzKig/OnBsdXJhbHxzZWxlY3R8c2VsZWN0b3JkaW5hbClcXHMqLFxccyovdSxcbiAgICAgICAgICAgIG5leHQ6ICdzZWxlY3QnLFxuICAgICAgICAgICAgdmFsdWU6IHNyYyA9PiBzcmMuc3BsaXQoJywnKVsxXS50cmltKClcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmMtYXJncyc6IHtcbiAgICAgICAgICAgIGxpbmVCcmVha3M6IHRydWUsXG4gICAgICAgICAgICBtYXRjaDogLyxcXHMqW15cXHB7UGF0X1N5bn1cXHB7UGF0X1dTfV0rXFxzKiwvdSxcbiAgICAgICAgICAgIG5leHQ6ICdib2R5JyxcbiAgICAgICAgICAgIHZhbHVlOiBzcmMgPT4gc3JjLnNwbGl0KCcsJylbMV0udHJpbSgpXG4gICAgICAgIH0sXG4gICAgICAgICdmdW5jLXNpbXBsZSc6IHtcbiAgICAgICAgICAgIGxpbmVCcmVha3M6IHRydWUsXG4gICAgICAgICAgICBtYXRjaDogLyxcXHMqW15cXHB7UGF0X1N5bn1cXHB7UGF0X1dTfV0rXFxzKi91LFxuICAgICAgICAgICAgdmFsdWU6IHNyYyA9PiBzcmMuc3Vic3RyaW5nKDEpLnRyaW0oKVxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHsgbWF0Y2g6ICd9JywgcG9wOiAxIH1cbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgIGxpbmVCcmVha3M6IHRydWUsXG4gICAgICAgICAgICBtYXRjaDogL1xccypvZmZzZXRcXHMqOlxccypcXGQrXFxzKi91LFxuICAgICAgICAgICAgdmFsdWU6IHNyYyA9PiBzcmMuc3BsaXQoJzonKVsxXS50cmltKClcbiAgICAgICAgfSxcbiAgICAgICAgY2FzZToge1xuICAgICAgICAgICAgbGluZUJyZWFrczogdHJ1ZSxcbiAgICAgICAgICAgIG1hdGNoOiAvXFxzKig/Oj1cXGQrfFteXFxwe1BhdF9TeW59XFxwe1BhdF9XU31dKylcXHMqXFx7L3UsXG4gICAgICAgICAgICBwdXNoOiAnYm9keScsXG4gICAgICAgICAgICB2YWx1ZTogc3JjID0+IHNyYy5zdWJzdHJpbmcoMCwgc3JjLmluZGV4T2YoJ3snKSkudHJpbSgpXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDogeyBtYXRjaDogL1xccypcXH0vdSwgcG9wOiAxIH1cbiAgICB9XG59O1xuZXhwb3J0cy5sZXhlciA9IG1vb18xLmRlZmF1bHQuc3RhdGVzKGV4cG9ydHMuc3RhdGVzKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@messageformat/parser/lib/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@messageformat/parser/lib/parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/@messageformat/parser/lib/parser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * An AST parser for ICU MessageFormat strings\n *\n * @packageDocumentation\n * @example\n * ```\n * import { parse } from '@messageformat/parser\n *\n * parse('So {wow}.')\n * [ { type: 'content', value: 'So ' },\n *   { type: 'argument', arg: 'wow' },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('Such { thing }. { count, selectordinal, one {First} two {Second}' +\n *       '                  few {Third} other {#th} } word.')\n * [ { type: 'content', value: 'Such ' },\n *   { type: 'argument', arg: 'thing' },\n *   { type: 'content', value: '. ' },\n *   { type: 'selectordinal',\n *     arg: 'count',\n *     cases: [\n *       { key: 'one', tokens: [ { type: 'content', value: 'First' } ] },\n *       { key: 'two', tokens: [ { type: 'content', value: 'Second' } ] },\n *       { key: 'few', tokens: [ { type: 'content', value: 'Third' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: 'th' } ] }\n *     ] },\n *   { type: 'content', value: ' word.' } ]\n *\n *\n * parse('Many{type,select,plural{ numbers}selectordinal{ counting}' +\n *                          'select{ choices}other{ some {type}}}.')\n * [ { type: 'content', value: 'Many' },\n *   { type: 'select',\n *     arg: 'type',\n *     cases: [\n *       { key: 'plural', tokens: [ { type: 'content', value: 'numbers' } ] },\n *       { key: 'selectordinal', tokens: [ { type: 'content', value: 'counting' } ] },\n *       { key: 'select', tokens: [ { type: 'content', value: 'choices' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'content', value: 'some ' }, { type: 'argument', arg: 'type' } ] }\n *     ] },\n *   { type: 'content', value: '.' } ]\n *\n *\n * parse('{Such compliance')\n * // ParseError: invalid syntax at line 1 col 7:\n * //\n * //  {Such compliance\n * //        ^\n *\n *\n * const msg = '{words, plural, zero{No words} one{One word} other{# words}}'\n * parse(msg)\n * [ { type: 'plural',\n *     arg: 'words',\n *     cases: [\n *       { key: 'zero', tokens: [ { type: 'content', value: 'No words' } ] },\n *       { key: 'one', tokens: [ { type: 'content', value: 'One word' } ] },\n *       { key: 'other',\n *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: ' words' } ] }\n *     ] } ]\n *\n *\n * parse(msg, { cardinal: [ 'one', 'other' ], ordinal: [ 'one', 'two', 'few', 'other' ] })\n * // ParseError: The plural case zero is not valid in this locale at line 1 col 17:\n * //\n * //   {words, plural, zero{\n * //                   ^\n * ```\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ParseError = void 0;\nexports.parse = parse;\nconst lexer_js_1 = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/@messageformat/parser/lib/lexer.js\");\nconst getContext = (lt) => ({\n    offset: lt.offset,\n    line: lt.line,\n    col: lt.col,\n    text: lt.text,\n    lineBreaks: lt.lineBreaks\n});\nconst isSelectType = (type) => type === 'plural' || type === 'select' || type === 'selectordinal';\nfunction strictArgStyleParam(lt, param) {\n    let value = '';\n    let text = '';\n    for (const p of param) {\n        const pText = p.ctx.text;\n        text += pText;\n        switch (p.type) {\n            case 'content':\n                value += p.value;\n                break;\n            case 'argument':\n            case 'function':\n            case 'octothorpe':\n                value += pText;\n                break;\n            default:\n                throw new ParseError(lt, `Unsupported part in strict mode function arg style: ${pText}`);\n        }\n    }\n    const c = {\n        type: 'content',\n        value: value.trim(),\n        ctx: Object.assign({}, param[0].ctx, { text })\n    };\n    return [c];\n}\nconst strictArgTypes = [\n    'number',\n    'date',\n    'time',\n    'spellout',\n    'ordinal',\n    'duration'\n];\nconst defaultPluralKeys = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Thrown by {@link parse} on error\n *\n * @public\n */\nclass ParseError extends Error {\n    /** @internal */\n    constructor(lt, msg) {\n        super(lexer_js_1.lexer.formatError(lt, msg));\n    }\n}\nexports.ParseError = ParseError;\nclass Parser {\n    constructor(src, opt) {\n        var _a, _b, _c, _d;\n        this.lexer = lexer_js_1.lexer.reset(src);\n        this.cardinalKeys = (_a = opt === null || opt === void 0 ? void 0 : opt.cardinal) !== null && _a !== void 0 ? _a : defaultPluralKeys;\n        this.ordinalKeys = (_b = opt === null || opt === void 0 ? void 0 : opt.ordinal) !== null && _b !== void 0 ? _b : defaultPluralKeys;\n        this.strict = (_c = opt === null || opt === void 0 ? void 0 : opt.strict) !== null && _c !== void 0 ? _c : false;\n        this.strictPluralKeys = (_d = opt === null || opt === void 0 ? void 0 : opt.strictPluralKeys) !== null && _d !== void 0 ? _d : true;\n    }\n    parse() {\n        return this.parseBody(false, true);\n    }\n    checkSelectKey(lt, type, key) {\n        if (key[0] === '=') {\n            if (type === 'select') {\n                throw new ParseError(lt, `The case ${key} is not valid with select`);\n            }\n        }\n        else if (type !== 'select') {\n            const keys = type === 'plural' ? this.cardinalKeys : this.ordinalKeys;\n            if (this.strictPluralKeys && keys.length > 0 && !keys.includes(key)) {\n                const msg = `The ${type} case ${key} is not valid in this locale`;\n                throw new ParseError(lt, msg);\n            }\n        }\n    }\n    parseSelect({ value: arg }, inPlural, ctx, type) {\n        const sel = { type, arg, cases: [], ctx };\n        if (type === 'plural' || type === 'selectordinal')\n            inPlural = true;\n        else if (this.strict)\n            inPlural = false;\n        for (const lt of this.lexer) {\n            switch (lt.type) {\n                case 'offset':\n                    if (type === 'select') {\n                        throw new ParseError(lt, 'Unexpected plural offset for select');\n                    }\n                    if (sel.cases.length > 0) {\n                        throw new ParseError(lt, 'Plural offset must be set before cases');\n                    }\n                    sel.pluralOffset = Number(lt.value);\n                    ctx.text += lt.text;\n                    ctx.lineBreaks += lt.lineBreaks;\n                    break;\n                case 'case': {\n                    this.checkSelectKey(lt, type, lt.value);\n                    sel.cases.push({\n                        key: lt.value,\n                        tokens: this.parseBody(inPlural),\n                        ctx: getContext(lt)\n                    });\n                    break;\n                }\n                case 'end':\n                    return sel;\n                /* istanbul ignore next: never happens */\n                default:\n                    throw new ParseError(lt, `Unexpected lexer token: ${lt.type}`);\n            }\n        }\n        throw new ParseError(null, 'Unexpected message end');\n    }\n    parseArgToken(lt, inPlural) {\n        const ctx = getContext(lt);\n        const argType = this.lexer.next();\n        if (!argType)\n            throw new ParseError(null, 'Unexpected message end');\n        ctx.text += argType.text;\n        ctx.lineBreaks += argType.lineBreaks;\n        if (this.strict &&\n            (argType.type === 'func-simple' || argType.type === 'func-args') &&\n            !strictArgTypes.includes(argType.value)) {\n            const msg = `Invalid strict mode function arg type: ${argType.value}`;\n            throw new ParseError(lt, msg);\n        }\n        switch (argType.type) {\n            case 'end':\n                return { type: 'argument', arg: lt.value, ctx };\n            case 'func-simple': {\n                const end = this.lexer.next();\n                if (!end)\n                    throw new ParseError(null, 'Unexpected message end');\n                /* istanbul ignore if: never happens */\n                if (end.type !== 'end') {\n                    throw new ParseError(end, `Unexpected lexer token: ${end.type}`);\n                }\n                ctx.text += end.text;\n                if (isSelectType(argType.value.toLowerCase())) {\n                    throw new ParseError(argType, `Invalid type identifier: ${argType.value}`);\n                }\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    ctx\n                };\n            }\n            case 'func-args': {\n                if (isSelectType(argType.value.toLowerCase())) {\n                    const msg = `Invalid type identifier: ${argType.value}`;\n                    throw new ParseError(argType, msg);\n                }\n                let param = this.parseBody(this.strict ? false : inPlural);\n                if (this.strict && param.length > 0) {\n                    param = strictArgStyleParam(lt, param);\n                }\n                return {\n                    type: 'function',\n                    arg: lt.value,\n                    key: argType.value,\n                    param,\n                    ctx\n                };\n            }\n            case 'select':\n                /* istanbul ignore else: never happens */\n                if (isSelectType(argType.value)) {\n                    return this.parseSelect(lt, inPlural, ctx, argType.value);\n                }\n                else {\n                    throw new ParseError(argType, `Unexpected select type ${argType.value}`);\n                }\n            /* istanbul ignore next: never happens */\n            default:\n                throw new ParseError(argType, `Unexpected lexer token: ${argType.type}`);\n        }\n    }\n    parseBody(inPlural, atRoot) {\n        const tokens = [];\n        let content = null;\n        for (const lt of this.lexer) {\n            if (lt.type === 'argument') {\n                if (content)\n                    content = null;\n                tokens.push(this.parseArgToken(lt, inPlural));\n            }\n            else if (lt.type === 'octothorpe' && inPlural) {\n                if (content)\n                    content = null;\n                tokens.push({ type: 'octothorpe', ctx: getContext(lt) });\n            }\n            else if (lt.type === 'end' && !atRoot) {\n                return tokens;\n            }\n            else {\n                let value = lt.value;\n                if (!inPlural && lt.type === 'quoted' && value[0] === '#') {\n                    if (value.includes('{')) {\n                        const errMsg = `Unsupported escape pattern: ${value}`;\n                        throw new ParseError(lt, errMsg);\n                    }\n                    value = lt.text;\n                }\n                if (content) {\n                    content.value += value;\n                    content.ctx.text += lt.text;\n                    content.ctx.lineBreaks += lt.lineBreaks;\n                }\n                else {\n                    content = { type: 'content', value, ctx: getContext(lt) };\n                    tokens.push(content);\n                }\n            }\n        }\n        if (atRoot)\n            return tokens;\n        throw new ParseError(null, 'Unexpected message end');\n    }\n}\n/**\n * Parse an input string into an array of tokens\n *\n * @public\n * @remarks\n * The parser only supports the default `DOUBLE_OPTIONAL`\n * {@link http://www.icu-project.org/apiref/icu4c/messagepattern_8h.html#af6e0757e0eb81c980b01ee5d68a9978b | apostrophe mode}.\n */\nfunction parse(src, options = {}) {\n    const parser = new Parser(src, options);\n    return parser.parse();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyL2xpYi9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLElBQUk7QUFDbEIsT0FBTywrQkFBK0I7QUFDdEMsT0FBTyw4QkFBOEI7QUFDckMsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBLGlCQUFpQixPQUFPLElBQUksMkJBQTJCLE9BQU8sS0FBSyxPQUFPO0FBQzFFLGlDQUFpQyxPQUFPLE9BQU8sT0FBTztBQUN0RCxPQUFPLGlDQUFpQztBQUN4QyxPQUFPLGdDQUFnQztBQUN2QyxPQUFPLDhCQUE4QjtBQUNyQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLFdBQVcsd0JBQXdCLGtDQUFrQyxHQUFHO0FBQ3hFLFdBQVcsd0JBQXdCLG1DQUFtQyxHQUFHO0FBQ3pFLFdBQVcsd0JBQXdCLGtDQUFrQyxHQUFHO0FBQ3hFLFdBQVc7QUFDWCx1QkFBdUIsb0JBQW9CLElBQUksK0JBQStCO0FBQzlFLFVBQVU7QUFDVixPQUFPLG1DQUFtQztBQUMxQztBQUNBO0FBQ0EsZUFBZSxvQkFBb0IsUUFBUSxlQUFlLFNBQVM7QUFDbkUscUNBQXFDLFFBQVEsT0FBTyxNQUFNLE9BQU87QUFDakUsT0FBTyxnQ0FBZ0M7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQixvQ0FBb0MsR0FBRztBQUM3RSxXQUFXLGtDQUFrQyxxQ0FBcUMsR0FBRztBQUNyRixXQUFXLDJCQUEyQixvQ0FBb0MsR0FBRztBQUM3RSxXQUFXO0FBQ1gsdUJBQXVCLGlDQUFpQyxJQUFJLGdDQUFnQztBQUM1RixVQUFVO0FBQ1YsT0FBTyw4QkFBOEI7QUFDckM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0IsVUFBVSxJQUFJLFVBQVUsTUFB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amVjdHMvZ2FsZW9uLWNvbW11bml0eS1ob3NwaXRhbC1tYXAvbWFpbi9ub2RlX21vZHVsZXMvQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyL2xpYi9wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFuIEFTVCBwYXJzZXIgZm9yIElDVSBNZXNzYWdlRm9ybWF0IHN0cmluZ3NcbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGltcG9ydCB7IHBhcnNlIH0gZnJvbSAnQG1lc3NhZ2Vmb3JtYXQvcGFyc2VyXG4gKlxuICogcGFyc2UoJ1NvIHt3b3d9LicpXG4gKiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ1NvICcgfSxcbiAqICAgeyB0eXBlOiAnYXJndW1lbnQnLCBhcmc6ICd3b3cnIH0sXG4gKiAgIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJy4nIH0gXVxuICpcbiAqXG4gKiBwYXJzZSgnU3VjaCB7IHRoaW5nIH0uIHsgY291bnQsIHNlbGVjdG9yZGluYWwsIG9uZSB7Rmlyc3R9IHR3byB7U2Vjb25kfScgK1xuICogICAgICAgJyAgICAgICAgICAgICAgICAgIGZldyB7VGhpcmR9IG90aGVyIHsjdGh9IH0gd29yZC4nKVxuICogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdTdWNoICcgfSxcbiAqICAgeyB0eXBlOiAnYXJndW1lbnQnLCBhcmc6ICd0aGluZycgfSxcbiAqICAgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnLiAnIH0sXG4gKiAgIHsgdHlwZTogJ3NlbGVjdG9yZGluYWwnLFxuICogICAgIGFyZzogJ2NvdW50JyxcbiAqICAgICBjYXNlczogW1xuICogICAgICAgeyBrZXk6ICdvbmUnLCB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnRmlyc3QnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICd0d28nLCB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnU2Vjb25kJyB9IF0gfSxcbiAqICAgICAgIHsga2V5OiAnZmV3JywgdG9rZW5zOiBbIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJ1RoaXJkJyB9IF0gfSxcbiAqICAgICAgIHsga2V5OiAnb3RoZXInLFxuICogICAgICAgICB0b2tlbnM6IFsgeyB0eXBlOiAnb2N0b3Rob3JwZScgfSwgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAndGgnIH0gXSB9XG4gKiAgICAgXSB9LFxuICogICB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICcgd29yZC4nIH0gXVxuICpcbiAqXG4gKiBwYXJzZSgnTWFueXt0eXBlLHNlbGVjdCxwbHVyYWx7IG51bWJlcnN9c2VsZWN0b3JkaW5hbHsgY291bnRpbmd9JyArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NlbGVjdHsgY2hvaWNlc31vdGhlcnsgc29tZSB7dHlwZX19fS4nKVxuICogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdNYW55JyB9LFxuICogICB7IHR5cGU6ICdzZWxlY3QnLFxuICogICAgIGFyZzogJ3R5cGUnLFxuICogICAgIGNhc2VzOiBbXG4gKiAgICAgICB7IGtleTogJ3BsdXJhbCcsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdudW1iZXJzJyB9IF0gfSxcbiAqICAgICAgIHsga2V5OiAnc2VsZWN0b3JkaW5hbCcsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdjb3VudGluZycgfSBdIH0sXG4gKiAgICAgICB7IGtleTogJ3NlbGVjdCcsIHRva2VuczogWyB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICdjaG9pY2VzJyB9IF0gfSxcbiAqICAgICAgIHsga2V5OiAnb3RoZXInLFxuICogICAgICAgICB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnc29tZSAnIH0sIHsgdHlwZTogJ2FyZ3VtZW50JywgYXJnOiAndHlwZScgfSBdIH1cbiAqICAgICBdIH0sXG4gKiAgIHsgdHlwZTogJ2NvbnRlbnQnLCB2YWx1ZTogJy4nIH0gXVxuICpcbiAqXG4gKiBwYXJzZSgne1N1Y2ggY29tcGxpYW5jZScpXG4gKiAvLyBQYXJzZUVycm9yOiBpbnZhbGlkIHN5bnRheCBhdCBsaW5lIDEgY29sIDc6XG4gKiAvL1xuICogLy8gIHtTdWNoIGNvbXBsaWFuY2VcbiAqIC8vICAgICAgICBeXG4gKlxuICpcbiAqIGNvbnN0IG1zZyA9ICd7d29yZHMsIHBsdXJhbCwgemVyb3tObyB3b3Jkc30gb25le09uZSB3b3JkfSBvdGhlcnsjIHdvcmRzfX0nXG4gKiBwYXJzZShtc2cpXG4gKiBbIHsgdHlwZTogJ3BsdXJhbCcsXG4gKiAgICAgYXJnOiAnd29yZHMnLFxuICogICAgIGNhc2VzOiBbXG4gKiAgICAgICB7IGtleTogJ3plcm8nLCB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnTm8gd29yZHMnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdvbmUnLCB0b2tlbnM6IFsgeyB0eXBlOiAnY29udGVudCcsIHZhbHVlOiAnT25lIHdvcmQnIH0gXSB9LFxuICogICAgICAgeyBrZXk6ICdvdGhlcicsXG4gKiAgICAgICAgIHRva2VuczogWyB7IHR5cGU6ICdvY3RvdGhvcnBlJyB9LCB7IHR5cGU6ICdjb250ZW50JywgdmFsdWU6ICcgd29yZHMnIH0gXSB9XG4gKiAgICAgXSB9IF1cbiAqXG4gKlxuICogcGFyc2UobXNnLCB7IGNhcmRpbmFsOiBbICdvbmUnLCAnb3RoZXInIF0sIG9yZGluYWw6IFsgJ29uZScsICd0d28nLCAnZmV3JywgJ290aGVyJyBdIH0pXG4gKiAvLyBQYXJzZUVycm9yOiBUaGUgcGx1cmFsIGNhc2UgemVybyBpcyBub3QgdmFsaWQgaW4gdGhpcyBsb2NhbGUgYXQgbGluZSAxIGNvbCAxNzpcbiAqIC8vXG4gKiAvLyAgIHt3b3JkcywgcGx1cmFsLCB6ZXJve1xuICogLy8gICAgICAgICAgICAgICAgICAgXlxuICogYGBgXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VFcnJvciA9IHZvaWQgMDtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmNvbnN0IGxleGVyX2pzXzEgPSByZXF1aXJlKFwiLi9sZXhlci5qc1wiKTtcbmNvbnN0IGdldENvbnRleHQgPSAobHQpID0+ICh7XG4gICAgb2Zmc2V0OiBsdC5vZmZzZXQsXG4gICAgbGluZTogbHQubGluZSxcbiAgICBjb2w6IGx0LmNvbCxcbiAgICB0ZXh0OiBsdC50ZXh0LFxuICAgIGxpbmVCcmVha3M6IGx0LmxpbmVCcmVha3Ncbn0pO1xuY29uc3QgaXNTZWxlY3RUeXBlID0gKHR5cGUpID0+IHR5cGUgPT09ICdwbHVyYWwnIHx8IHR5cGUgPT09ICdzZWxlY3QnIHx8IHR5cGUgPT09ICdzZWxlY3RvcmRpbmFsJztcbmZ1bmN0aW9uIHN0cmljdEFyZ1N0eWxlUGFyYW0obHQsIHBhcmFtKSB7XG4gICAgbGV0IHZhbHVlID0gJyc7XG4gICAgbGV0IHRleHQgPSAnJztcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGFyYW0pIHtcbiAgICAgICAgY29uc3QgcFRleHQgPSBwLmN0eC50ZXh0O1xuICAgICAgICB0ZXh0ICs9IHBUZXh0O1xuICAgICAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29udGVudCc6XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FyZ3VtZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ29jdG90aG9ycGUnOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHBUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihsdCwgYFVuc3VwcG9ydGVkIHBhcnQgaW4gc3RyaWN0IG1vZGUgZnVuY3Rpb24gYXJnIHN0eWxlOiAke3BUZXh0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGMgPSB7XG4gICAgICAgIHR5cGU6ICdjb250ZW50JyxcbiAgICAgICAgdmFsdWU6IHZhbHVlLnRyaW0oKSxcbiAgICAgICAgY3R4OiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbVswXS5jdHgsIHsgdGV4dCB9KVxuICAgIH07XG4gICAgcmV0dXJuIFtjXTtcbn1cbmNvbnN0IHN0cmljdEFyZ1R5cGVzID0gW1xuICAgICdudW1iZXInLFxuICAgICdkYXRlJyxcbiAgICAndGltZScsXG4gICAgJ3NwZWxsb3V0JyxcbiAgICAnb3JkaW5hbCcsXG4gICAgJ2R1cmF0aW9uJ1xuXTtcbmNvbnN0IGRlZmF1bHRQbHVyYWxLZXlzID0gWyd6ZXJvJywgJ29uZScsICd0d28nLCAnZmV3JywgJ21hbnknLCAnb3RoZXInXTtcbi8qKlxuICogVGhyb3duIGJ5IHtAbGluayBwYXJzZX0gb24gZXJyb3JcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGNvbnN0cnVjdG9yKGx0LCBtc2cpIHtcbiAgICAgICAgc3VwZXIobGV4ZXJfanNfMS5sZXhlci5mb3JtYXRFcnJvcihsdCwgbXNnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjtcbmNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3Ioc3JjLCBvcHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLmxleGVyID0gbGV4ZXJfanNfMS5sZXhlci5yZXNldChzcmMpO1xuICAgICAgICB0aGlzLmNhcmRpbmFsS2V5cyA9IChfYSA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5jYXJkaW5hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFBsdXJhbEtleXM7XG4gICAgICAgIHRoaXMub3JkaW5hbEtleXMgPSAoX2IgPSBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQub3JkaW5hbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFBsdXJhbEtleXM7XG4gICAgICAgIHRoaXMuc3RyaWN0ID0gKF9jID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LnN0cmljdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaWN0UGx1cmFsS2V5cyA9IChfZCA9IG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5zdHJpY3RQbHVyYWxLZXlzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlO1xuICAgIH1cbiAgICBwYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCb2R5KGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgY2hlY2tTZWxlY3RLZXkobHQsIHR5cGUsIGtleSkge1xuICAgICAgICBpZiAoa2V5WzBdID09PSAnPScpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCBgVGhlIGNhc2UgJHtrZXl9IGlzIG5vdCB2YWxpZCB3aXRoIHNlbGVjdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdHlwZSA9PT0gJ3BsdXJhbCcgPyB0aGlzLmNhcmRpbmFsS2V5cyA6IHRoaXMub3JkaW5hbEtleXM7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpY3RQbHVyYWxLZXlzICYmIGtleXMubGVuZ3RoID4gMCAmJiAha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFRoZSAke3R5cGV9IGNhc2UgJHtrZXl9IGlzIG5vdCB2YWxpZCBpbiB0aGlzIGxvY2FsZWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VTZWxlY3QoeyB2YWx1ZTogYXJnIH0sIGluUGx1cmFsLCBjdHgsIHR5cGUpIHtcbiAgICAgICAgY29uc3Qgc2VsID0geyB0eXBlLCBhcmcsIGNhc2VzOiBbXSwgY3R4IH07XG4gICAgICAgIGlmICh0eXBlID09PSAncGx1cmFsJyB8fCB0eXBlID09PSAnc2VsZWN0b3JkaW5hbCcpXG4gICAgICAgICAgICBpblBsdXJhbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0KVxuICAgICAgICAgICAgaW5QbHVyYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBsdCBvZiB0aGlzLmxleGVyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGx0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdvZmZzZXQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCAnVW5leHBlY3RlZCBwbHVyYWwgb2Zmc2V0IGZvciBzZWxlY3QnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsLmNhc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCAnUGx1cmFsIG9mZnNldCBtdXN0IGJlIHNldCBiZWZvcmUgY2FzZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWwucGx1cmFsT2Zmc2V0ID0gTnVtYmVyKGx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnRleHQgKz0gbHQudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVCcmVha3MgKz0gbHQubGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2FzZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1NlbGVjdEtleShsdCwgdHlwZSwgbHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZWwuY2FzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLnBhcnNlQm9keShpblBsdXJhbCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHg6IGdldENvbnRleHQobHQpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbDtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogbmV2ZXIgaGFwcGVucyAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCBgVW5leHBlY3RlZCBsZXhlciB0b2tlbjogJHtsdC50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKG51bGwsICdVbmV4cGVjdGVkIG1lc3NhZ2UgZW5kJyk7XG4gICAgfVxuICAgIHBhcnNlQXJnVG9rZW4obHQsIGluUGx1cmFsKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHQobHQpO1xuICAgICAgICBjb25zdCBhcmdUeXBlID0gdGhpcy5sZXhlci5uZXh0KCk7XG4gICAgICAgIGlmICghYXJnVHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKG51bGwsICdVbmV4cGVjdGVkIG1lc3NhZ2UgZW5kJyk7XG4gICAgICAgIGN0eC50ZXh0ICs9IGFyZ1R5cGUudGV4dDtcbiAgICAgICAgY3R4LmxpbmVCcmVha3MgKz0gYXJnVHlwZS5saW5lQnJlYWtzO1xuICAgICAgICBpZiAodGhpcy5zdHJpY3QgJiZcbiAgICAgICAgICAgIChhcmdUeXBlLnR5cGUgPT09ICdmdW5jLXNpbXBsZScgfHwgYXJnVHlwZS50eXBlID09PSAnZnVuYy1hcmdzJykgJiZcbiAgICAgICAgICAgICFzdHJpY3RBcmdUeXBlcy5pbmNsdWRlcyhhcmdUeXBlLnZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEludmFsaWQgc3RyaWN0IG1vZGUgZnVuY3Rpb24gYXJnIHR5cGU6ICR7YXJnVHlwZS52YWx1ZX1gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobHQsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhcmdUeXBlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FyZ3VtZW50JywgYXJnOiBsdC52YWx1ZSwgY3R4IH07XG4gICAgICAgICAgICBjYXNlICdmdW5jLXNpbXBsZSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmxleGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVuZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobnVsbCwgJ1VuZXhwZWN0ZWQgbWVzc2FnZSBlbmQnKTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IG5ldmVyIGhhcHBlbnMgKi9cbiAgICAgICAgICAgICAgICBpZiAoZW5kLnR5cGUgIT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGVuZCwgYFVuZXhwZWN0ZWQgbGV4ZXIgdG9rZW46ICR7ZW5kLnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0ICs9IGVuZC50ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChpc1NlbGVjdFR5cGUoYXJnVHlwZS52YWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihhcmdUeXBlLCBgSW52YWxpZCB0eXBlIGlkZW50aWZpZXI6ICR7YXJnVHlwZS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgYXJnOiBsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBhcmdUeXBlLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZnVuYy1hcmdzJzoge1xuICAgICAgICAgICAgICAgIGlmIChpc1NlbGVjdFR5cGUoYXJnVHlwZS52YWx1ZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgSW52YWxpZCB0eXBlIGlkZW50aWZpZXI6ICR7YXJnVHlwZS52YWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihhcmdUeXBlLCBtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyYW0gPSB0aGlzLnBhcnNlQm9keSh0aGlzLnN0cmljdCA/IGZhbHNlIDogaW5QbHVyYWwpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdCAmJiBwYXJhbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtID0gc3RyaWN0QXJnU3R5bGVQYXJhbShsdCwgcGFyYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBhcmc6IGx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IGFyZ1R5cGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtLFxuICAgICAgICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogbmV2ZXIgaGFwcGVucyAqL1xuICAgICAgICAgICAgICAgIGlmIChpc1NlbGVjdFR5cGUoYXJnVHlwZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTZWxlY3QobHQsIGluUGx1cmFsLCBjdHgsIGFyZ1R5cGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYXJnVHlwZSwgYFVuZXhwZWN0ZWQgc2VsZWN0IHR5cGUgJHthcmdUeXBlLnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBuZXZlciBoYXBwZW5zICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGFyZ1R5cGUsIGBVbmV4cGVjdGVkIGxleGVyIHRva2VuOiAke2FyZ1R5cGUudHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUJvZHkoaW5QbHVyYWwsIGF0Um9vdCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGx0IG9mIHRoaXMubGV4ZXIpIHtcbiAgICAgICAgICAgIGlmIChsdC50eXBlID09PSAnYXJndW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMucGFyc2VBcmdUb2tlbihsdCwgaW5QbHVyYWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGx0LnR5cGUgPT09ICdvY3RvdGhvcnBlJyAmJiBpblBsdXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50KVxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6ICdvY3RvdGhvcnBlJywgY3R4OiBnZXRDb250ZXh0KGx0KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGx0LnR5cGUgPT09ICdlbmQnICYmICFhdFJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpblBsdXJhbCAmJiBsdC50eXBlID09PSAncXVvdGVkJyAmJiB2YWx1ZVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBgVW5zdXBwb3J0ZWQgZXNjYXBlIHBhdHRlcm46ICR7dmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGx0LCBlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbHQudGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5jdHgudGV4dCArPSBsdC50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LmN0eC5saW5lQnJlYWtzICs9IGx0LmxpbmVCcmVha3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0geyB0eXBlOiAnY29udGVudCcsIHZhbHVlLCBjdHg6IGdldENvbnRleHQobHQpIH07XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXRSb290KVxuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IobnVsbCwgJ1VuZXhwZWN0ZWQgbWVzc2FnZSBlbmQnKTtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHRva2Vuc1xuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzXG4gKiBUaGUgcGFyc2VyIG9ubHkgc3VwcG9ydHMgdGhlIGRlZmF1bHQgYERPVUJMRV9PUFRJT05BTGBcbiAqIHtAbGluayBodHRwOi8vd3d3LmljdS1wcm9qZWN0Lm9yZy9hcGlyZWYvaWN1NGMvbWVzc2FnZXBhdHRlcm5fOGguaHRtbCNhZjZlMDc1N2UwZWI4MWM5ODBiMDFlZTVkNjhhOTk3OGIgfCBhcG9zdHJvcGhlIG1vZGV9LlxuICovXG5mdW5jdGlvbiBwYXJzZShzcmMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoc3JjLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@messageformat/parser/lib/parser.js\n");

/***/ })

};
;